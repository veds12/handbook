{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The ERC Handbook Welcome! The ERC Handbook is an extensive compilation of information and resources for everything robotics made by the Electronics and Robotics Club, BITS Goa.","title":"Home"},{"location":"#the-erc-handbook","text":"Welcome! The ERC Handbook is an extensive compilation of information and resources for everything robotics made by the Electronics and Robotics Club, BITS Goa.","title":"The ERC Handbook"},{"location":"CHANGELOG/","text":"Changelog Unreleased Full Changelog Implemented enhancements: Make Contribution Guidelines #5 Fixed bugs: Development boards/arduino images cannot be displayed #28 Closed issues: fix images and equation in kinematics and dynamics section #37 Add a section about STM \\(ARM\\) programming #25 Add colcon under catkin #14 Website build error #9 Arrange the subtopics of automation, electronics and mechanics in a logical order #8 Fix the security dependency issue #6 Add a suitable picture for the home page #4 Create initial subsections using the Summer Assignment resources section #3 Remove all initial metadata and add title has ERC handbook #2 Move frontpage to documentation #1 Merged pull requests: [31/10/2020] Added Drive Mechanism #44 ( Ashutosh781 ) [25/10/2020] Added a section about STM32 #43 ( adbidwai ) [25/10/20] added control theory #41 ( pranavgo ) [25/09/2020]Added STDR Simulator #40 ( SuhrudhSarathy ) [01/09/2020] Fixed image and math issues #39 ( pranavgo ) [31/08/2020] Added Dynamics and Kinematics #36 ( pranavgo ) [30/08/2020] Added Gears.md #31 ( Ashutosh781 ) added breadboard.md, attr_list for image resizing #29 ( enceladus2000 ) [16/08/2020]Added Arduino section under Dev Boards #27 ( Ashutosh781 ) [09/08/2020] Added miscellaneous resources #26 ( hardesh ) [31/08/2020] Added PathPlanning, A*, Dijkstra\u2019s, RRT #24 ( SuhrudhSarathy ) [04/08/20] Added information about ROS Parameters #21 ( adbidwai ) [03/08/20] Changelog Test 2 #20 ( veds12 ) changelog test #19 ( veds12 ) [01/08/20] Test1 for auto changelog generator #18 ( veds12 ) [01/08/20] Added information about colcon in GETTING STARTED WITH ROS #17 ( veds12 ) Update mkdocs.yml #12 ( Ashutosh781 ) * This Changelog was automatically generated by github_changelog_generator","title":"Updates"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"Full Changelog Implemented enhancements: Make Contribution Guidelines #5 Fixed bugs: Development boards/arduino images cannot be displayed #28 Closed issues: fix images and equation in kinematics and dynamics section #37 Add a section about STM \\(ARM\\) programming #25 Add colcon under catkin #14 Website build error #9 Arrange the subtopics of automation, electronics and mechanics in a logical order #8 Fix the security dependency issue #6 Add a suitable picture for the home page #4 Create initial subsections using the Summer Assignment resources section #3 Remove all initial metadata and add title has ERC handbook #2 Move frontpage to documentation #1 Merged pull requests: [31/10/2020] Added Drive Mechanism #44 ( Ashutosh781 ) [25/10/2020] Added a section about STM32 #43 ( adbidwai ) [25/10/20] added control theory #41 ( pranavgo ) [25/09/2020]Added STDR Simulator #40 ( SuhrudhSarathy ) [01/09/2020] Fixed image and math issues #39 ( pranavgo ) [31/08/2020] Added Dynamics and Kinematics #36 ( pranavgo ) [30/08/2020] Added Gears.md #31 ( Ashutosh781 ) added breadboard.md, attr_list for image resizing #29 ( enceladus2000 ) [16/08/2020]Added Arduino section under Dev Boards #27 ( Ashutosh781 ) [09/08/2020] Added miscellaneous resources #26 ( hardesh ) [31/08/2020] Added PathPlanning, A*, Dijkstra\u2019s, RRT #24 ( SuhrudhSarathy ) [04/08/20] Added information about ROS Parameters #21 ( adbidwai ) [03/08/20] Changelog Test 2 #20 ( veds12 ) changelog test #19 ( veds12 ) [01/08/20] Test1 for auto changelog generator #18 ( veds12 ) [01/08/20] Added information about colcon in GETTING STARTED WITH ROS #17 ( veds12 ) Update mkdocs.yml #12 ( Ashutosh781 ) * This Changelog was automatically generated by github_changelog_generator","title":"Unreleased"},{"location":"about/","text":"About Us The Electronics and Robotics Club (ERC) of BITS Goa is a diverse group of students with interests ranging from electronics to machine learning to mechanical design. Over the years, we have evolved into a platform to learn and experiment with various aspects of science and engineering and to apply them in robotics. We are open to anyone with a general interest in engineering and who wants to explore robotics, so feel free to get in touch with us. This handbook is part of an effort from our side to provide an organised set of learning resources to make it easy for anyone to get started with the field of robotics. We have compiled a bunch of staple and commonly used resources in an orderly fashion giving a breadth-first overview of basic concepts essential in all the three significant verticals of robotics: Design, Electronics and Control and Automation . The field of robotics is very vast and rapidly moving forward, exploring new and unique things. Currently, the handbook has content related to introductory robotics, and our current effort is focused on including more relevant information and resources. We are open to and would love to have any contributions or suggestions from your side, helping us improve and add new material to the handbook. Feel free to open an issue or PRs to the repository :) We hope this handbook helps you in some or the other way! You can find out more about us at our website and read our blog articles.","title":"About Us"},{"location":"about/#about-us","text":"The Electronics and Robotics Club (ERC) of BITS Goa is a diverse group of students with interests ranging from electronics to machine learning to mechanical design. Over the years, we have evolved into a platform to learn and experiment with various aspects of science and engineering and to apply them in robotics. We are open to anyone with a general interest in engineering and who wants to explore robotics, so feel free to get in touch with us. This handbook is part of an effort from our side to provide an organised set of learning resources to make it easy for anyone to get started with the field of robotics. We have compiled a bunch of staple and commonly used resources in an orderly fashion giving a breadth-first overview of basic concepts essential in all the three significant verticals of robotics: Design, Electronics and Control and Automation . The field of robotics is very vast and rapidly moving forward, exploring new and unique things. Currently, the handbook has content related to introductory robotics, and our current effort is focused on including more relevant information and resources. We are open to and would love to have any contributions or suggestions from your side, helping us improve and add new material to the handbook. Feel free to open an issue or PRs to the repository :) We hope this handbook helps you in some or the other way! You can find out more about us at our website and read our blog articles.","title":"About Us"},{"location":"misc/","text":"Miscellaneous Online Courses Underactuated robotics Programming for Robotics Introduction to Aerial Robotics SLAM Course Robotics Specialization - Coursera Modern Robotics Specialization - Coursera Compiled list of other courses/resources Wesbites with resources The Robotics Back-End RoboticsKnowledgeBase Talk Series / Seminars / Podcasts Artificial Intelligence Podcast by Lex Fridman Robotics Today MIT RoboSeminars Stanford - Robotics and Autonomous Systems Seminar CMU RI Robotics Seminars List of Mailing lists and Google Groups Robotics Worldwide European Robotics AI Robotics Systems Neuroscience ML-news Connectionists UAI Reinforcement Learning Deep Learning Neuromorphic Engineering Computer Vision Artificial Life Genetic Programming","title":"Miscellaneous Resources"},{"location":"misc/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"misc/#online-courses","text":"Underactuated robotics Programming for Robotics Introduction to Aerial Robotics SLAM Course Robotics Specialization - Coursera Modern Robotics Specialization - Coursera Compiled list of other courses/resources","title":"Online Courses"},{"location":"misc/#wesbites-with-resources","text":"The Robotics Back-End RoboticsKnowledgeBase","title":"Wesbites with resources"},{"location":"misc/#talk-series-seminars-podcasts","text":"Artificial Intelligence Podcast by Lex Fridman Robotics Today MIT RoboSeminars Stanford - Robotics and Autonomous Systems Seminar CMU RI Robotics Seminars","title":"Talk Series / Seminars / Podcasts"},{"location":"misc/#list-of-mailing-lists-and-google-groups","text":"Robotics Worldwide European Robotics AI Robotics Systems Neuroscience ML-news Connectionists UAI Reinforcement Learning Deep Learning Neuromorphic Engineering Computer Vision Artificial Life Genetic Programming","title":"List of Mailing lists and Google Groups"},{"location":"automation/intro/","text":"Introduction","title":"Introduction"},{"location":"automation/intro/#introduction","text":"","title":"Introduction"},{"location":"automation/ControlTheory/Control_Theory/","text":"Control Theory A robot can exhibit a number of different behaviors, depending on the task and its environment. It can act as a source of programmed motions for tasks such as moving an object from one place to another or tracing a trajectory. It can act as a source of forces, as when applying a polishing wheel to a workpiece. In tasks such as writing on a chalkboard, it must control forces in some directions (the force must press the chalk against the board) and motions in others (the motion must be in the plane of the board). When the purpose of the robot is to act as a haptic display, rendering a virtual environment, we may want it to act like a spring, damper, or mass, yielding in response to forces applied to it. In each of these cases, it is the job of the robot controller to convert the task specification to forces and torques at the actuators. Control strategies that achieve the behaviors described above are known as motion control , force control , hybrid motion-force control , or impedance control . A typical control block diagram is shown above The sensors are typically: potentiometers, encoders, or resolvers for joint position and angle sensing; tachometers for joint velocity sensing; joint force-torque sensors; and/or multi-axis force-torque sensors. Types of control systems Open Loop control system A control system in which the control action is totally independent of output of the system then it is called open loop control system . A manual control system is also an open loop control system. The figure below shows a control system block diagram of an open loop control system in which process output is totally independent of the controller action. Practical examples of Open loop control system: Electric Hand Drier \u2013 Hot air (output) comes out as long as you keep your hand under the machine, irrespective of how much your hand is dried. Automatic Washing Machine \u2013 This machine runs according to the pre-set time irrespective of washing is completed or not. Bread Toaster \u2013 This machine runs as per adjusted time irrespective of toasting is completed or not. Closed Loop control system Control system in which the output has an effect on the input quantity in such a manner that the input quantity will adjust itself based on the output generated is called closed loop control system . Open loop control system can be converted in to closed loop control system by providing a feedback. Figure below shows the block diagram of closed loop control system in which feedback is taken from output and fed in to input. Practical example of Closed loop control system: Missile Launched and Auto Tracked by Radar \u2013 The direction of missile is controlled by comparing the target and position of the missile. An Air Conditioner \u2013 An air conditioner functions depending upon the temperature of the room. Cooling System in Car \u2013 It operates depending upon the temperature which it controls. Core topics in Control Theory Before we design any controller, we have to consider the key factors that will drive the robot and how are we supposed to build the controller that will drive us to the best results which are also known as control objectives . These factors are listed below: 1. Stability : By this, we mean to measure the level of stability in the signal which will drive the object and also keep a check on the fluctuation of the signal. For eg. if we are making a cruise controller for a car, then the controller should give a stable signal after the car has reached the cruising speed and the speed should remain constant (no fluctuations). 2. Tracking : It is necessary to give controls after analyzing the response given due to the input signal. For instance, in a cruise controller, after setting up cruising speed, it is necessary for the controller to keep a regular check on the speed by which it can decide whether to accelerate or retard. 3. Robustness : Robust control systems often incorporate advanced topologies which include multiple feedback loops and feed-forward paths. The control laws may be represented by high order transfer functions required to simultaneously accomplish desired disturbance rejection performance with robust closed loop operation. For example, the controller should not be hard coded to function only for a certain velocity ,say 50 miles/hour if designing a cruise control. 4. Disturbance : It refers to the noise (not useful signal) that the controller might signal while sending or any sort of attenuation that can happen. It actually depends on the quality of instruments used in making a controller and also due to some external factors. 5. Optimality : It is a set of differential equations that describe the paths of the control variables that minimize the cost function. Laplace transform The Laplace transform plays a important role in control theory. It appears in the description of linear time invariant systems, where it changes convolution operators into multiplication operators and allows to define the transfer function of a system. The properties of systems can be then translated into properties of the transfer function. It allows the use of graphical methods to predict system performance without solving the differential equations of the system. These include response, steady state behavior, and transient behavior. Laplace Vs Fourier transform Laplace transform: \\(F(s)=\\int_{0}^{\\infty}f(t)e^{-st}dt \\qquad f^{'}(t)\\Rightarrow sF(s)\\) Fourier transform: \\(F(\\omega) = \\int_{-\\infty}^{\\infty}f(t)e^{-j\\omega t}dt\\) Laplace transforms often depend on the initial value of the function whereas Fourier transforms are independent of the initial value. The transforms are only the same if the function is the same both sides of the y-axis (so the unit step function is different). To understand Laplace transform in detail read this article Closed Loop Transfer Function A closed-loop transfer function in control theory is a mathematical expression describing the net result of the effects of a closed feedback loop on the input signal to the circuits enclosed by the loop. Where: block G represents the open-loop gains of the controller or system and is the forward path, and block H represents the gain of the sensor, transducer or measurement system in the feedback path. To find the transfer function of the closed-loop system above, we must first calculate the output signal \u03b8 o in terms of the input signal \u03b8 i . To do so, we can easily write the equations of the given block-diagram as follows. The output from the system is equal to: Output = G x Error Note that the error signal, \u03b8 e is also the input to the feed-forward block: G The output from the summing point is equal to: Error = Input - H x Output If H = 1 (unity feedback) then: The output from the summing point will be: Error (\u03b8 e ) = Input - Output Eliminating the error term, then: The output is equal to: Output = G x (Input - H x Output) Therefore: G x Input = Output + G x H x Output Rearranging the above gives us the closed-loop transfer function of: Controllability Types of Feedback Control Positive Feedback In a \u201cpositive feedback control system\u201d, the set point and output values are added together by the controller as the feedback is \u201cin-phase\u201d with the input. The effect of positive (or regenerative) feedback is to \u201cincrease\u201d the systems gain, i.e, the overall gain with positive feedback applied will be greater than the gain without feedback] Negative Feedback In a \u201cnegative feedback control system\u201d, the set point and output values are subtracted from each other as the feedback is \u201cout-of-phase\u201d with the original input. The effect of negative (or degenerative) feedback is to \u201creduce\u201d the gain. As a rule negative feedback systems are more stable than positive feedback systems. Negative feedback also makes systems more immune to random variations in component values and inputs. To know more about different types of control systems you can read this article.","title":"Introduction to Control Theory"},{"location":"automation/ControlTheory/Control_Theory/#control-theory","text":"A robot can exhibit a number of different behaviors, depending on the task and its environment. It can act as a source of programmed motions for tasks such as moving an object from one place to another or tracing a trajectory. It can act as a source of forces, as when applying a polishing wheel to a workpiece. In tasks such as writing on a chalkboard, it must control forces in some directions (the force must press the chalk against the board) and motions in others (the motion must be in the plane of the board). When the purpose of the robot is to act as a haptic display, rendering a virtual environment, we may want it to act like a spring, damper, or mass, yielding in response to forces applied to it. In each of these cases, it is the job of the robot controller to convert the task specification to forces and torques at the actuators. Control strategies that achieve the behaviors described above are known as motion control , force control , hybrid motion-force control , or impedance control . A typical control block diagram is shown above The sensors are typically: potentiometers, encoders, or resolvers for joint position and angle sensing; tachometers for joint velocity sensing; joint force-torque sensors; and/or multi-axis force-torque sensors.","title":"Control Theory"},{"location":"automation/ControlTheory/Control_Theory/#types-of-control-systems","text":"","title":"Types of control systems"},{"location":"automation/ControlTheory/Control_Theory/#open-loop-control-system","text":"A control system in which the control action is totally independent of output of the system then it is called open loop control system . A manual control system is also an open loop control system. The figure below shows a control system block diagram of an open loop control system in which process output is totally independent of the controller action. Practical examples of Open loop control system: Electric Hand Drier \u2013 Hot air (output) comes out as long as you keep your hand under the machine, irrespective of how much your hand is dried. Automatic Washing Machine \u2013 This machine runs according to the pre-set time irrespective of washing is completed or not. Bread Toaster \u2013 This machine runs as per adjusted time irrespective of toasting is completed or not.","title":"Open Loop control system"},{"location":"automation/ControlTheory/Control_Theory/#closed-loop-control-system","text":"Control system in which the output has an effect on the input quantity in such a manner that the input quantity will adjust itself based on the output generated is called closed loop control system . Open loop control system can be converted in to closed loop control system by providing a feedback. Figure below shows the block diagram of closed loop control system in which feedback is taken from output and fed in to input. Practical example of Closed loop control system: Missile Launched and Auto Tracked by Radar \u2013 The direction of missile is controlled by comparing the target and position of the missile. An Air Conditioner \u2013 An air conditioner functions depending upon the temperature of the room. Cooling System in Car \u2013 It operates depending upon the temperature which it controls.","title":"Closed Loop control system"},{"location":"automation/ControlTheory/Control_Theory/#core-topics-in-control-theory","text":"Before we design any controller, we have to consider the key factors that will drive the robot and how are we supposed to build the controller that will drive us to the best results which are also known as control objectives . These factors are listed below: 1. Stability : By this, we mean to measure the level of stability in the signal which will drive the object and also keep a check on the fluctuation of the signal. For eg. if we are making a cruise controller for a car, then the controller should give a stable signal after the car has reached the cruising speed and the speed should remain constant (no fluctuations). 2. Tracking : It is necessary to give controls after analyzing the response given due to the input signal. For instance, in a cruise controller, after setting up cruising speed, it is necessary for the controller to keep a regular check on the speed by which it can decide whether to accelerate or retard. 3. Robustness : Robust control systems often incorporate advanced topologies which include multiple feedback loops and feed-forward paths. The control laws may be represented by high order transfer functions required to simultaneously accomplish desired disturbance rejection performance with robust closed loop operation. For example, the controller should not be hard coded to function only for a certain velocity ,say 50 miles/hour if designing a cruise control. 4. Disturbance : It refers to the noise (not useful signal) that the controller might signal while sending or any sort of attenuation that can happen. It actually depends on the quality of instruments used in making a controller and also due to some external factors. 5. Optimality : It is a set of differential equations that describe the paths of the control variables that minimize the cost function.","title":"Core topics in Control Theory"},{"location":"automation/ControlTheory/Control_Theory/#laplace-transform","text":"The Laplace transform plays a important role in control theory. It appears in the description of linear time invariant systems, where it changes convolution operators into multiplication operators and allows to define the transfer function of a system. The properties of systems can be then translated into properties of the transfer function. It allows the use of graphical methods to predict system performance without solving the differential equations of the system. These include response, steady state behavior, and transient behavior.","title":"Laplace transform"},{"location":"automation/ControlTheory/Control_Theory/#laplace-vs-fourier-transform","text":"Laplace transform: \\(F(s)=\\int_{0}^{\\infty}f(t)e^{-st}dt \\qquad f^{'}(t)\\Rightarrow sF(s)\\) Fourier transform: \\(F(\\omega) = \\int_{-\\infty}^{\\infty}f(t)e^{-j\\omega t}dt\\) Laplace transforms often depend on the initial value of the function whereas Fourier transforms are independent of the initial value. The transforms are only the same if the function is the same both sides of the y-axis (so the unit step function is different). To understand Laplace transform in detail read this article","title":"Laplace Vs Fourier transform"},{"location":"automation/ControlTheory/Control_Theory/#closed-loop-transfer-function","text":"A closed-loop transfer function in control theory is a mathematical expression describing the net result of the effects of a closed feedback loop on the input signal to the circuits enclosed by the loop. Where: block G represents the open-loop gains of the controller or system and is the forward path, and block H represents the gain of the sensor, transducer or measurement system in the feedback path. To find the transfer function of the closed-loop system above, we must first calculate the output signal \u03b8 o in terms of the input signal \u03b8 i . To do so, we can easily write the equations of the given block-diagram as follows. The output from the system is equal to: Output = G x Error Note that the error signal, \u03b8 e is also the input to the feed-forward block: G The output from the summing point is equal to: Error = Input - H x Output If H = 1 (unity feedback) then: The output from the summing point will be: Error (\u03b8 e ) = Input - Output Eliminating the error term, then: The output is equal to: Output = G x (Input - H x Output) Therefore: G x Input = Output + G x H x Output Rearranging the above gives us the closed-loop transfer function of:","title":"Closed Loop Transfer Function"},{"location":"automation/ControlTheory/Control_Theory/#controllability","text":"","title":"Controllability"},{"location":"automation/ControlTheory/Control_Theory/#types-of-feedback-control","text":"","title":"Types of Feedback Control"},{"location":"automation/ControlTheory/Control_Theory/#positive-feedback","text":"In a \u201cpositive feedback control system\u201d, the set point and output values are added together by the controller as the feedback is \u201cin-phase\u201d with the input. The effect of positive (or regenerative) feedback is to \u201cincrease\u201d the systems gain, i.e, the overall gain with positive feedback applied will be greater than the gain without feedback]","title":"Positive Feedback"},{"location":"automation/ControlTheory/Control_Theory/#negative-feedback","text":"In a \u201cnegative feedback control system\u201d, the set point and output values are subtracted from each other as the feedback is \u201cout-of-phase\u201d with the original input. The effect of negative (or degenerative) feedback is to \u201creduce\u201d the gain. As a rule negative feedback systems are more stable than positive feedback systems. Negative feedback also makes systems more immune to random variations in component values and inputs. To know more about different types of control systems you can read this article.","title":"Negative Feedback"},{"location":"automation/ControlTheory/LQR/","text":"Linear-Quadratic Regulator(LQR) Controller The theory of optimal control is concerned with operating a dynamic system at minimum cost. The case where the system dynamics are described by a set of linear differential equations and the cost is described by a quadratic function is called the LQ problem. One of the main results in the theory is that the solution is provided by the linear\u2013quadratic regulator ( LQR ). The settings of a (regulating) controller governing either a machine or process (like an airplane or chemical reactor) are found by using a mathematical algorithm that minimizes a cost function with weighting factors needed to be supplied. A cost function is a function that maps an event or values of one or more variables onto a real number intuitively representing some \u201ccost\u201d associated with the event. The cost function is often defined as a sum of the deviations of key measurements, like altitude or process temperature, from their desired values. The algorithm thus finds those controller settings that minimize undesired deviations. The magnitude of the control action itself may also be included in the cost function. Finite horizon LQR For a continuous-time linear system, defined on \\(t \\epsilon [t_0,t_1]\\) , described by: \\(\\dot{x} = Ax + Bu\\) with a quadratic cost function defined as: \\(J = x^T (t_1)F(t_1)x(t_1) + \\int_{t_0}^{t_1} (x^TQx + u^TRu + 2x^TNu) \\,dt\\) the feedback control law that minimizes the value of the cost is: \\(u = -Kx\\) where K is given by: \\(K = R^{-1}(B^TP(t) + N^t)\\) and P is found by solving the continuous time Riccati differential equation : \\(A^TP(t) + P(t)A - (P(t)B+N)R^{-1}(B^TP(t) + N^T) + Q = - \\dot{P}(t)\\) with the boundary condition: \\(P(t_1)=F(t_1)\\) To learn more in detail about LQR controller watch this video by Steve Brunton Linear Quadratic Gaussian (LQG) control theory Here, Given a linear model of the plant in a statespace description, and assuming that the disturbance and measurement noise are Gaussian stochastic processes with known power spectral densities, the designer translates the design specifications into a quadratic performance criterion consisting of some state variables and control signal inputs. The object of design then is to minimize the performance criterion by using appropriate state or measurement feedback controllers while guaranteeing the closed-loop stability. When LQG controller problem is solved in a deterministic setting, known as an H 2 optimal control problem, in which the H 2 norm of a certain transfer function from an exogenous disturbance to a pertinent controlled output of a given plant is minimized by appropriate use of an internally stabilizing controller. To learn about robust controllers and LQG control problem in detail watch this video H\u221e (i.e. \u201c H-infinity \u201d) methods are used in control theory to synthesize controllers to achieve stabilization with guaranteed performance. To use H \u221e methods, a control designer expresses the control problem as a mathematical optimization problem and then finds the controller that solves this optimization. H \u221e techniques have the advantage over classical control techniques in that H \u221e techniques are readily applicable to problems involving multivariate systems with cross-coupling between channels. Read this material from MIT Open Courseware to know about H\u221e methods in more detail.","title":"Linear Quadratic Regulator"},{"location":"automation/ControlTheory/LQR/#linear-quadratic-regulatorlqr-controller","text":"The theory of optimal control is concerned with operating a dynamic system at minimum cost. The case where the system dynamics are described by a set of linear differential equations and the cost is described by a quadratic function is called the LQ problem. One of the main results in the theory is that the solution is provided by the linear\u2013quadratic regulator ( LQR ). The settings of a (regulating) controller governing either a machine or process (like an airplane or chemical reactor) are found by using a mathematical algorithm that minimizes a cost function with weighting factors needed to be supplied. A cost function is a function that maps an event or values of one or more variables onto a real number intuitively representing some \u201ccost\u201d associated with the event. The cost function is often defined as a sum of the deviations of key measurements, like altitude or process temperature, from their desired values. The algorithm thus finds those controller settings that minimize undesired deviations. The magnitude of the control action itself may also be included in the cost function.","title":"Linear-Quadratic Regulator(LQR) Controller"},{"location":"automation/ControlTheory/LQR/#finite-horizon-lqr","text":"For a continuous-time linear system, defined on \\(t \\epsilon [t_0,t_1]\\) , described by: \\(\\dot{x} = Ax + Bu\\) with a quadratic cost function defined as: \\(J = x^T (t_1)F(t_1)x(t_1) + \\int_{t_0}^{t_1} (x^TQx + u^TRu + 2x^TNu) \\,dt\\) the feedback control law that minimizes the value of the cost is: \\(u = -Kx\\) where K is given by: \\(K = R^{-1}(B^TP(t) + N^t)\\) and P is found by solving the continuous time Riccati differential equation : \\(A^TP(t) + P(t)A - (P(t)B+N)R^{-1}(B^TP(t) + N^T) + Q = - \\dot{P}(t)\\) with the boundary condition: \\(P(t_1)=F(t_1)\\) To learn more in detail about LQR controller watch this video by Steve Brunton","title":"Finite horizon LQR"},{"location":"automation/ControlTheory/LQR/#linear-quadratic-gaussian-lqg-control-theory","text":"Here, Given a linear model of the plant in a statespace description, and assuming that the disturbance and measurement noise are Gaussian stochastic processes with known power spectral densities, the designer translates the design specifications into a quadratic performance criterion consisting of some state variables and control signal inputs. The object of design then is to minimize the performance criterion by using appropriate state or measurement feedback controllers while guaranteeing the closed-loop stability. When LQG controller problem is solved in a deterministic setting, known as an H 2 optimal control problem, in which the H 2 norm of a certain transfer function from an exogenous disturbance to a pertinent controlled output of a given plant is minimized by appropriate use of an internally stabilizing controller. To learn about robust controllers and LQG control problem in detail watch this video H\u221e (i.e. \u201c H-infinity \u201d) methods are used in control theory to synthesize controllers to achieve stabilization with guaranteed performance. To use H \u221e methods, a control designer expresses the control problem as a mathematical optimization problem and then finds the controller that solves this optimization. H \u221e techniques have the advantage over classical control techniques in that H \u221e techniques are readily applicable to problems involving multivariate systems with cross-coupling between channels. Read this material from MIT Open Courseware to know about H\u221e methods in more detail.","title":"Linear Quadratic Gaussian (LQG) control theory"},{"location":"automation/ControlTheory/MPC/","text":"Model Based Controllers Model-based control uses information about the dynamics of the system\u2019s structure and its behavior in time to obtain a better control result regarding stability and performance of the controlled system. Take the following simple example: Let \\(\\frac{d^2x}{dt^2}= f(x)+u\\) be the system to be controlled, where x - state vector, f(x) - nonlinear vector function, u - control vector. Suppose we have some estimation est(x) than we use a control law like \\(u = -est(x)+u_{st}\\) where u st be some maybe linear PID control law \\(u_{st} = K_px + K_d\\frac{dx}{dt} + K_i\\int xdt\\) So we get \\(\\frac{d^2x}{dt^2} = \\Delta f + K_px + K_d\\frac{dx}{dt} + K_i\\int xdt\\) where \\(\\Delta f =f(x) - est(x)\\) If the model uncertainties are small enough we get a linear system with a disturbance Delta f which can be stabilized using appropriate control gains K p , K d , K I . Above given is just an example of model based controller in real life model based controller are way more complex than this. Model Predictive Control(MPC) is the most widely known model based controller. Model Predictive Controllers rely on the dynamic models of the process, most often linear empirical models obtained by system identification. Model predictive control offers several important advantages: (1) the process model captures the dynamic and static interactions between input, output, and disturbance variables, (2) constraints on inputs and outputs are considered in a systematic manner, (3) the control calculations can be coordinated with the calculation of optimum set points, and (4) accurate model predictions can provide early warnings of potential problems. The mathematics and concepts involved in MPC are a bit complex and require a decent understanding of mathematics of control theory. To study more about MPC controller read this material by NTNU You can also check this video by Steve Brunton to get a more detailed idea Some of the other resources you should check to understand control theory and various controllers in more detail are: Control Bootcamp playlist by Steve Brunton Control Systems Lectures by Brian Douglas Control of Mobile Robots course by Georgia Tech University on Coursera Modern Robotics - Mechanical, Planning and Control by Kevin.M.Lynch and Frank.C.Park MIT Courseware Control Theory Notes","title":"Model Predictive Control"},{"location":"automation/ControlTheory/MPC/#model-based-controllers","text":"Model-based control uses information about the dynamics of the system\u2019s structure and its behavior in time to obtain a better control result regarding stability and performance of the controlled system. Take the following simple example: Let \\(\\frac{d^2x}{dt^2}= f(x)+u\\) be the system to be controlled, where x - state vector, f(x) - nonlinear vector function, u - control vector. Suppose we have some estimation est(x) than we use a control law like \\(u = -est(x)+u_{st}\\) where u st be some maybe linear PID control law \\(u_{st} = K_px + K_d\\frac{dx}{dt} + K_i\\int xdt\\) So we get \\(\\frac{d^2x}{dt^2} = \\Delta f + K_px + K_d\\frac{dx}{dt} + K_i\\int xdt\\) where \\(\\Delta f =f(x) - est(x)\\) If the model uncertainties are small enough we get a linear system with a disturbance Delta f which can be stabilized using appropriate control gains K p , K d , K I . Above given is just an example of model based controller in real life model based controller are way more complex than this. Model Predictive Control(MPC) is the most widely known model based controller. Model Predictive Controllers rely on the dynamic models of the process, most often linear empirical models obtained by system identification. Model predictive control offers several important advantages: (1) the process model captures the dynamic and static interactions between input, output, and disturbance variables, (2) constraints on inputs and outputs are considered in a systematic manner, (3) the control calculations can be coordinated with the calculation of optimum set points, and (4) accurate model predictions can provide early warnings of potential problems. The mathematics and concepts involved in MPC are a bit complex and require a decent understanding of mathematics of control theory. To study more about MPC controller read this material by NTNU You can also check this video by Steve Brunton to get a more detailed idea Some of the other resources you should check to understand control theory and various controllers in more detail are: Control Bootcamp playlist by Steve Brunton Control Systems Lectures by Brian Douglas Control of Mobile Robots course by Georgia Tech University on Coursera Modern Robotics - Mechanical, Planning and Control by Kevin.M.Lynch and Frank.C.Park MIT Courseware Control Theory Notes","title":"Model Based Controllers"},{"location":"automation/ControlTheory/PID_Controller/","text":"Linear Control Techniques Linear Control technique is the most widely used technique for designing control systems in robotics because of its simple implementation when your system is operating in vicinity of a particular point. Some of the common linear control system design techniques, includes the well-known PID control, H 2 and H \\(\\infty\\) optimal control, linear quadratic regulator (LQR) with loop transfer recovery design (LTR) , and some newly developed design techniques, such as the robust and perfect tracking (RPT) method. PID Controller PID control is the most popular technique used in industries because it is relatively easy and simple to design and implement. Most importantly, it works in most practical situations, although its performance is somewhat limited owing to its restricted structure. Hence, a PID control law has the following general form for the input command: \\(u(t) = K~p~e(t) + K~i~\\int e(t) + K~d~\\frac{de(t)}{dt}\\) where \\(e = q - q~d~\\) is the error signal, and \\(K~p~, K~i~\\) and \\(K~d~\\) are positive constant gains associated with proportional, integral, and derivative controllers. Consider the control system , in which G(s) is the plant to be controlled and K(s) is the PID controller, it can be characterized by the following transfer function: \\(K(s) = K~p~(1+\\frac{1}{Tis}+Tds)\\) The control system design is then to determine the parameters K p , T i and T d such that the resulting dosed-loop system yields a certain desired performance, i.e. it meets certain prescribed design specifications. Proportional factor The proportional factor is easiest to understand: The output of the proportional factor is the product of gain and measured error \u03b5. Hence, larger proportional gain or error makes for greater output from the proportional factor. Setting the proportional gain too high causes a controller to repeatedly overshoot the setpoint, leading to oscillation. The downside to a proportional-only loop is that when error becomes too small, loop output becomes negligible. Therefore, even when the proportional loop reaches steady state, there is still error. The larger the proportional gain, the smaller the steady state error \u2014 but the larger the proportional gain, the more likely the loop is to become unstable. This dilemma leads to inevitable steady-state error called offset . Integral Factor The main function of an integral control is to eliminate the steady state error and make the system follow the set point at steady state conditions. The integral controller leads to an increasing control command for a positive error, and a decreasing control command for a negative error. The downside to the integral factor is that it strongly contributes to controller output overshoot past the target setpoint. The shorter the integral time, the more aggressively the integral works. Derivative Factor The purpose of derivative control is to improve the closed-loop stability of a system. A derivative controller has a predicting action by extrapolating the error using a tangent to the error curve. The derivative factor is the least understood and used of the three factors. In fact, a majority of PID loops in the real world are really just PI loops. A properly used derivative allows for more aggressive proportional and integral factors. PID Tuning Method The determination of corresponding PID parameter values for getting the optimum performance from the process is called tuning. This is obviously a crucial part in case of all closed loop control systems. There are number of tuning methods have been introduced to obtain fast and acceptable performance. Trial and Error Method This is the simple method of tuning a PID controller. Once we get the clear understanding of PID parameters, the trial and error method become relatively easy. Set integral and derivative terms to zero first and then increase the proportional gain until the output of the control loop oscillates at a constant rate. This increase of proportional gain should be in such that response the system becomes faster provided it should not make system unstable. Once the P-response is fast enough, set the integral term, so that the oscillations will be gradually reduced. Change this I-value until the steady state error is reduced, but it may increase overshoot. Once P and I parameters have been set to a desired values with minimal steady state error, increase the derivative gain until the system reacts quickly to its set point. Increasing derivative term decreases the overshoot of the controller response. Zeigler-Nichols Method It is another popular method for tuning PID controllers. Ziegler and Nichols presented two classical methods for determining values of proportional gain, integral time and derivative time based on transient response characteristics of a given plant or system. First Method Obtain a unit step response of the plant experimentally and it may look\u2018s\u2019 shaped curve as shown in figure below. This method applies, if obtained response exhibit s-shaped curve for unit step input otherwise it cannot be applied. This curve can also be obtained by dynamic simulation of the plant. Obtain two constants, delay time L and time constant T by drawing a tangent line at the inflection point of the s-shaped curve. Set the parameters of K p , T i , and T d values from the table given below for three types of controllers. Second Method It is very similar to the trial and error method where integral and derivative terms are set to the zero, i.e., making Ti infinity and Td zero. Increase the proportional gain such that the output exhibits sustained oscillations. If the system does not produce sustained oscillations then this method cannot be applied. The gain at which sustained oscillations produced is called as critical gain. Once the sustain oscillations are produced, set the values of Ti and Td as per the given table for P, PI and PID controllers based on critical gain and critical period. Recently many intelligent methods have also been developed for tuning PID controllers one of such method is using genetic algorithms. To learn more about this method watch this 2 part video by Steve Brunton.","title":"PID Controller"},{"location":"automation/ControlTheory/PID_Controller/#linear-control-techniques","text":"Linear Control technique is the most widely used technique for designing control systems in robotics because of its simple implementation when your system is operating in vicinity of a particular point. Some of the common linear control system design techniques, includes the well-known PID control, H 2 and H \\(\\infty\\) optimal control, linear quadratic regulator (LQR) with loop transfer recovery design (LTR) , and some newly developed design techniques, such as the robust and perfect tracking (RPT) method.","title":"Linear Control Techniques"},{"location":"automation/ControlTheory/PID_Controller/#pid-controller","text":"PID control is the most popular technique used in industries because it is relatively easy and simple to design and implement. Most importantly, it works in most practical situations, although its performance is somewhat limited owing to its restricted structure. Hence, a PID control law has the following general form for the input command: \\(u(t) = K~p~e(t) + K~i~\\int e(t) + K~d~\\frac{de(t)}{dt}\\) where \\(e = q - q~d~\\) is the error signal, and \\(K~p~, K~i~\\) and \\(K~d~\\) are positive constant gains associated with proportional, integral, and derivative controllers. Consider the control system , in which G(s) is the plant to be controlled and K(s) is the PID controller, it can be characterized by the following transfer function: \\(K(s) = K~p~(1+\\frac{1}{Tis}+Tds)\\) The control system design is then to determine the parameters K p , T i and T d such that the resulting dosed-loop system yields a certain desired performance, i.e. it meets certain prescribed design specifications.","title":"PID Controller"},{"location":"automation/ControlTheory/PID_Controller/#proportional-factor","text":"The proportional factor is easiest to understand: The output of the proportional factor is the product of gain and measured error \u03b5. Hence, larger proportional gain or error makes for greater output from the proportional factor. Setting the proportional gain too high causes a controller to repeatedly overshoot the setpoint, leading to oscillation. The downside to a proportional-only loop is that when error becomes too small, loop output becomes negligible. Therefore, even when the proportional loop reaches steady state, there is still error. The larger the proportional gain, the smaller the steady state error \u2014 but the larger the proportional gain, the more likely the loop is to become unstable. This dilemma leads to inevitable steady-state error called offset .","title":"Proportional factor"},{"location":"automation/ControlTheory/PID_Controller/#integral-factor","text":"The main function of an integral control is to eliminate the steady state error and make the system follow the set point at steady state conditions. The integral controller leads to an increasing control command for a positive error, and a decreasing control command for a negative error. The downside to the integral factor is that it strongly contributes to controller output overshoot past the target setpoint. The shorter the integral time, the more aggressively the integral works.","title":"Integral Factor"},{"location":"automation/ControlTheory/PID_Controller/#derivative-factor","text":"The purpose of derivative control is to improve the closed-loop stability of a system. A derivative controller has a predicting action by extrapolating the error using a tangent to the error curve. The derivative factor is the least understood and used of the three factors. In fact, a majority of PID loops in the real world are really just PI loops. A properly used derivative allows for more aggressive proportional and integral factors.","title":"Derivative Factor"},{"location":"automation/ControlTheory/PID_Controller/#pid-tuning-method","text":"The determination of corresponding PID parameter values for getting the optimum performance from the process is called tuning. This is obviously a crucial part in case of all closed loop control systems. There are number of tuning methods have been introduced to obtain fast and acceptable performance.","title":"PID Tuning Method"},{"location":"automation/ControlTheory/PID_Controller/#trial-and-error-method","text":"This is the simple method of tuning a PID controller. Once we get the clear understanding of PID parameters, the trial and error method become relatively easy. Set integral and derivative terms to zero first and then increase the proportional gain until the output of the control loop oscillates at a constant rate. This increase of proportional gain should be in such that response the system becomes faster provided it should not make system unstable. Once the P-response is fast enough, set the integral term, so that the oscillations will be gradually reduced. Change this I-value until the steady state error is reduced, but it may increase overshoot. Once P and I parameters have been set to a desired values with minimal steady state error, increase the derivative gain until the system reacts quickly to its set point. Increasing derivative term decreases the overshoot of the controller response.","title":"Trial and Error Method"},{"location":"automation/ControlTheory/PID_Controller/#zeigler-nichols-method","text":"It is another popular method for tuning PID controllers. Ziegler and Nichols presented two classical methods for determining values of proportional gain, integral time and derivative time based on transient response characteristics of a given plant or system.","title":"Zeigler-Nichols Method"},{"location":"automation/ControlTheory/PID_Controller/#first-method","text":"Obtain a unit step response of the plant experimentally and it may look\u2018s\u2019 shaped curve as shown in figure below. This method applies, if obtained response exhibit s-shaped curve for unit step input otherwise it cannot be applied. This curve can also be obtained by dynamic simulation of the plant. Obtain two constants, delay time L and time constant T by drawing a tangent line at the inflection point of the s-shaped curve. Set the parameters of K p , T i , and T d values from the table given below for three types of controllers.","title":"First Method"},{"location":"automation/ControlTheory/PID_Controller/#second-method","text":"It is very similar to the trial and error method where integral and derivative terms are set to the zero, i.e., making Ti infinity and Td zero. Increase the proportional gain such that the output exhibits sustained oscillations. If the system does not produce sustained oscillations then this method cannot be applied. The gain at which sustained oscillations produced is called as critical gain. Once the sustain oscillations are produced, set the values of Ti and Td as per the given table for P, PI and PID controllers based on critical gain and critical period. Recently many intelligent methods have also been developed for tuning PID controllers one of such method is using genetic algorithms. To learn more about this method watch this 2 part video by Steve Brunton.","title":"Second Method"},{"location":"automation/PathPlanners/Astar/","text":"A-Star Algorithm A-star is a graph-based, path search algorithm. It is used in many fields of computer science as a search algorithm. It is often used due to its completeness, optimality, and optimal efficiency. Salient Features of the Algorithm Resolution complete and Resolution optimal : The algorithm finds the optimal solution to the given problem at a chosen discretization, if one exits. A-Star uses a hueristic to estimate the total cost of a solution constrained to pass through a state. Thus, it searches in order of decreasing solution quality and is optimally efficient . Any other optimal algorithm using the same hueristic will expand at least as many vertices as A-Star. Idea of Hueristics Functions Hueristic functions are used to map every node in the graph to a non-negative value. Criteria for Hueristics Functions Should be a monotonic function Should satisfy \\(H(goal) = 0\\) For any two adjacent nodes \\(x\\) and \\(y\\) : \\(H(x, y) \\leq H(y) + d(x, y)\\) \\(d(x, y) = EdgeCost(x, y)\\) These properties ensure that for all nodes \\(n\\) : \\(H(n) \\leq length of Shortest Path(n, GOAL)\\) For path Planning on a grid: Euclidean Distance: \\(H(x_n, y_n) = \\sqrt{(x_n-x_g)^2 + (y_n-y_g)^2}\\) Manhattan Distance: \\(H(x_n, y_n) = \\lvert(x_n - x_g) + (y_n - y_g)\\rvert\\) Where \\(x_n\\) , \\(y_n\\) and \\(x_g\\) , \\(y_g\\) are the \\(x\\) , \\(y\\) coordinates of a the node and the goal respectively. Psuedo Code for the Algorithm def Astar ( start , goal , graph ): # Set the g, f values for all nodes in the graph for node in graph : node . f = Infinity node . g = Infinity # Create an empty list to store visited nodes nodes = [] # Add Start to nodes list nodes . add ( start ) # Loop to traverse the graph while nodes is not EMPTY : # Obtain bode with the least f-value CURRENT = argmin ( node , criteria = node . f ) # Check if current node is the goal Node # which means the graph has been completely traversed if CURRENT == goal : report \"SUCCESS\" break # Update parameters for adjacent nodes for adjacent_node in CURRENT . adjacent_nodes : if adjacent_node . g > CURRENT . g + cost of edge from n to current : adjacent_node . g = CURRENT . g + cost of edge from n to current adjacent_node . f = adjacent_node . g + H ( node ) adjacent_node . parent = CURRENT # Add the adjacent node to nodes list if not there already if adjacent_node not in nodes : nodes . add ( adjacent_node ) Notations in the Psuedo Code explained : g-value = distance between a node and the start node H-function = Hueristic funciton f-value = g-value + Hueristic value of the node References Original paper on A-Star path planning algorithm. Psuedo Code can be found here Video explainig A-star can be found here","title":"A Star"},{"location":"automation/PathPlanners/Astar/#a-star-algorithm","text":"A-star is a graph-based, path search algorithm. It is used in many fields of computer science as a search algorithm. It is often used due to its completeness, optimality, and optimal efficiency.","title":"A-Star Algorithm"},{"location":"automation/PathPlanners/Astar/#salient-features-of-the-algorithm","text":"Resolution complete and Resolution optimal : The algorithm finds the optimal solution to the given problem at a chosen discretization, if one exits. A-Star uses a hueristic to estimate the total cost of a solution constrained to pass through a state. Thus, it searches in order of decreasing solution quality and is optimally efficient . Any other optimal algorithm using the same hueristic will expand at least as many vertices as A-Star.","title":"Salient Features of the Algorithm"},{"location":"automation/PathPlanners/Astar/#idea-of-hueristics-functions","text":"Hueristic functions are used to map every node in the graph to a non-negative value.","title":"Idea of Hueristics Functions"},{"location":"automation/PathPlanners/Astar/#criteria-for-hueristics-functions","text":"Should be a monotonic function Should satisfy \\(H(goal) = 0\\) For any two adjacent nodes \\(x\\) and \\(y\\) : \\(H(x, y) \\leq H(y) + d(x, y)\\) \\(d(x, y) = EdgeCost(x, y)\\) These properties ensure that for all nodes \\(n\\) : \\(H(n) \\leq length of Shortest Path(n, GOAL)\\)","title":"Criteria for Hueristics Functions"},{"location":"automation/PathPlanners/Astar/#for-path-planning-on-a-grid","text":"Euclidean Distance: \\(H(x_n, y_n) = \\sqrt{(x_n-x_g)^2 + (y_n-y_g)^2}\\) Manhattan Distance: \\(H(x_n, y_n) = \\lvert(x_n - x_g) + (y_n - y_g)\\rvert\\) Where \\(x_n\\) , \\(y_n\\) and \\(x_g\\) , \\(y_g\\) are the \\(x\\) , \\(y\\) coordinates of a the node and the goal respectively.","title":"For path Planning on a grid:"},{"location":"automation/PathPlanners/Astar/#psuedo-code-for-the-algorithm","text":"def Astar ( start , goal , graph ): # Set the g, f values for all nodes in the graph for node in graph : node . f = Infinity node . g = Infinity # Create an empty list to store visited nodes nodes = [] # Add Start to nodes list nodes . add ( start ) # Loop to traverse the graph while nodes is not EMPTY : # Obtain bode with the least f-value CURRENT = argmin ( node , criteria = node . f ) # Check if current node is the goal Node # which means the graph has been completely traversed if CURRENT == goal : report \"SUCCESS\" break # Update parameters for adjacent nodes for adjacent_node in CURRENT . adjacent_nodes : if adjacent_node . g > CURRENT . g + cost of edge from n to current : adjacent_node . g = CURRENT . g + cost of edge from n to current adjacent_node . f = adjacent_node . g + H ( node ) adjacent_node . parent = CURRENT # Add the adjacent node to nodes list if not there already if adjacent_node not in nodes : nodes . add ( adjacent_node ) Notations in the Psuedo Code explained : g-value = distance between a node and the start node H-function = Hueristic funciton f-value = g-value + Hueristic value of the node","title":"Psuedo Code for the Algorithm"},{"location":"automation/PathPlanners/Astar/#references","text":"Original paper on A-Star path planning algorithm. Psuedo Code can be found here Video explainig A-star can be found here","title":"References"},{"location":"automation/PathPlanners/Dijkstra/","text":"Dikstra\u2019s Algorithm Dijkstra\u2019s Algorithm is an algorithm for finding the shortest path between one source node and all the other nodes in a graph, thereby producing a shortest-path-tree . Psuedo Code # Set the distances if all nodes in the graph to infinty for node in graph : node . distance = INFINITY # Create an empty list nodes = [] # Set the start distance to ZERO START . distance = 0 # Add start to the list nodes . add ( START ) # Loop to update distances while nodes is not empty : CURRENT = argmin ( node , criteria = node . distance ) if CURRENT == GOAL : report \"Success\" break for adjacent_node in CURRENT . adjacent_nodes : if adjacent_node . distance > CURRENT . distance + cost of edge from CURRENT to adjacent_node : adjacent_node . distance = CURRENT . distance + cost of edge from CURRENT to adjacent_node adjacent_node . parent = CURRENT # Add adjacent_node to the list, if it is not already present if adjacent_node not in nodes : nodes . add ( adjacent_node ) References: Psuedo Code for Dijkstra\u2019s Algorithm can be found here A video explaining Dijkstra\u2019s Algorithm can be found here","title":"Dijkstra's Algorithm"},{"location":"automation/PathPlanners/Dijkstra/#dikstras-algorithm","text":"Dijkstra\u2019s Algorithm is an algorithm for finding the shortest path between one source node and all the other nodes in a graph, thereby producing a shortest-path-tree .","title":"Dikstra's Algorithm"},{"location":"automation/PathPlanners/Dijkstra/#psuedo-code","text":"# Set the distances if all nodes in the graph to infinty for node in graph : node . distance = INFINITY # Create an empty list nodes = [] # Set the start distance to ZERO START . distance = 0 # Add start to the list nodes . add ( START ) # Loop to update distances while nodes is not empty : CURRENT = argmin ( node , criteria = node . distance ) if CURRENT == GOAL : report \"Success\" break for adjacent_node in CURRENT . adjacent_nodes : if adjacent_node . distance > CURRENT . distance + cost of edge from CURRENT to adjacent_node : adjacent_node . distance = CURRENT . distance + cost of edge from CURRENT to adjacent_node adjacent_node . parent = CURRENT # Add adjacent_node to the list, if it is not already present if adjacent_node not in nodes : nodes . add ( adjacent_node )","title":"Psuedo Code"},{"location":"automation/PathPlanners/Dijkstra/#references","text":"Psuedo Code for Dijkstra\u2019s Algorithm can be found here A video explaining Dijkstra\u2019s Algorithm can be found here","title":"References:"},{"location":"automation/PathPlanners/RRT/","text":"Rapidly Exploring Random Trees Salient Features Randomly samples nodes in the Configuration space of the robot to build a tree of valid configurations. It is Probabilistically Complete ,having the probability to find a solution if it exists . In worst case, time taken to find a solution can be very long (longer than exhaustive search). The probability of finding a solution goes to \\(1\\) as number of sampled nodes goes to \\(\\infty\\) . In practise, the algorithm tends to be very effecitve in high dimensional spaces. There is no gaurantee regarding the optimality of the solution. The path produced my bot the the shortest path. Post processing of the path generated is required as the path generated is often very unordered or in zig-zag fashion. Collision Checking Function One important requirement of sampling algorithms, is the ability to check if a configuration is valid or not. To check if a configuration \\(X\\) is valid in a configuration free space \\(\\mathbb{C}\\) , a function as such can be used: \\[ CollisionCheck(X) = \\begin{cases} 0 \\quad &\\text{if} \\, X \\in \\mathbb{C} \\\\ 1 \\quad &\\text{if} \\, X \\notin \\mathbb{C} \\end{cases} \\\\ \\] Psuedo Code def RRT ( START , GOAL ): TREE = [] TREE . add ( START ) DELTA = maximum distance between sampled node and nearest node . REPEAT n times : X = generateNewConfiguration () if X in FREE_SPACE : for nodes in TREE : Y = argmin ( nodes , criteria = distance ) if DIST ( X , Y ) < DELTA : Find a configuration Z that is at DELTA distance along the path from X to Y if TRAVERSABLE ( X , Z ): X . parent = Y TREE . add ( X ) else : if TRAVERSABLE ( X , Y ): X . parent = Y TREE . add ( X ) if X is GOAL : report \"SUCCESS\" break Notations and Functions used in Psuedo Code: Function used to check if a path is traversable: \\[ Traversable(X, Y) = \\begin{cases} 1 \\quad &\\text{if} \\, \\operatorname{LineJoining}(X, Y) \\in \\mathbb{C} \\\\ 0 \\quad &\\text{if} \\, \\operatorname{LineJoining}(X, Y) \\notin \\mathbb{C} \\\\ \\end{cases} \\] In case of Rotations: \\[ Dist(X, Y) = \\min{(\\lvert X_n - Y_n \\rvert}, \\lvert\\ 2\\pi - \\lvert X_n - Y_n \\rvert \\rvert) \\] References Refer this article for more information about RRT and RRT* A video explaining RRT algorithm. Refer to the paper here","title":"RRT"},{"location":"automation/PathPlanners/RRT/#rapidly-exploring-random-trees","text":"","title":"Rapidly Exploring Random Trees"},{"location":"automation/PathPlanners/RRT/#salient-features","text":"Randomly samples nodes in the Configuration space of the robot to build a tree of valid configurations. It is Probabilistically Complete ,having the probability to find a solution if it exists . In worst case, time taken to find a solution can be very long (longer than exhaustive search). The probability of finding a solution goes to \\(1\\) as number of sampled nodes goes to \\(\\infty\\) . In practise, the algorithm tends to be very effecitve in high dimensional spaces. There is no gaurantee regarding the optimality of the solution. The path produced my bot the the shortest path. Post processing of the path generated is required as the path generated is often very unordered or in zig-zag fashion.","title":"Salient Features"},{"location":"automation/PathPlanners/RRT/#collision-checking-function","text":"One important requirement of sampling algorithms, is the ability to check if a configuration is valid or not. To check if a configuration \\(X\\) is valid in a configuration free space \\(\\mathbb{C}\\) , a function as such can be used: \\[ CollisionCheck(X) = \\begin{cases} 0 \\quad &\\text{if} \\, X \\in \\mathbb{C} \\\\ 1 \\quad &\\text{if} \\, X \\notin \\mathbb{C} \\end{cases} \\\\ \\]","title":"Collision Checking Function"},{"location":"automation/PathPlanners/RRT/#psuedo-code","text":"def RRT ( START , GOAL ): TREE = [] TREE . add ( START ) DELTA = maximum distance between sampled node and nearest node . REPEAT n times : X = generateNewConfiguration () if X in FREE_SPACE : for nodes in TREE : Y = argmin ( nodes , criteria = distance ) if DIST ( X , Y ) < DELTA : Find a configuration Z that is at DELTA distance along the path from X to Y if TRAVERSABLE ( X , Z ): X . parent = Y TREE . add ( X ) else : if TRAVERSABLE ( X , Y ): X . parent = Y TREE . add ( X ) if X is GOAL : report \"SUCCESS\" break","title":"Psuedo Code"},{"location":"automation/PathPlanners/RRT/#notations-and-functions-used-in-psuedo-code","text":"Function used to check if a path is traversable: \\[ Traversable(X, Y) = \\begin{cases} 1 \\quad &\\text{if} \\, \\operatorname{LineJoining}(X, Y) \\in \\mathbb{C} \\\\ 0 \\quad &\\text{if} \\, \\operatorname{LineJoining}(X, Y) \\notin \\mathbb{C} \\\\ \\end{cases} \\] In case of Rotations: \\[ Dist(X, Y) = \\min{(\\lvert X_n - Y_n \\rvert}, \\lvert\\ 2\\pi - \\lvert X_n - Y_n \\rvert \\rvert) \\]","title":"Notations and Functions used in Psuedo Code:"},{"location":"automation/PathPlanners/RRT/#references","text":"Refer this article for more information about RRT and RRT* A video explaining RRT algorithm. Refer to the paper here","title":"References"},{"location":"automation/PathPlanners/intro/","text":"Path Planning in Robotics What is a path? Path, as the name suggests is a set of waypoints which a Robot is expected to travel. There can be many criterions for deciding a path that the Robot should follow. Various optimisations, checks are made before deciding an optimial path. Why Planning is important for Autonomous Robots? Path planning is one of the most important primitives for autonomous mobile robots. The ability to be able to travel on its own by finding a collision free, optimal path is an important aspect of making robots autonomous Path planning for Autonomous Robots Path planning, as illustrated above is an important aspect of autonomous robots. There are various methods how a path is planned. There are various algorithms on path planning. Some of the common features of path planners are: 1. Given a start and a goal position(or pose), give out a set of states(positions or velocities) that the robot should take to reach the goal from start. 2. The path generated should be collision free with the obstacles in the environment. 3. Generally the path generated should optimise some hueristic(or parameter). 4. The path generated should be traversable by a robot given its dynamics. Path Planning algorithms The problem to find an optimal path has been studied since many decades. There are many algorithms that are graph-based , sampling-based . Each branch follows a particular approach to solve the path planning problem. 1. Graph based algorithms: Graph based algorithms overlay a topological graph on a robots configurational space and perform search for an optimal path. Some of the notable graph-based algorithms are: Dijkstra\u2019s Algorithm A-Star (A*) D-Star (D*) 2. Sampling based algorithms: Sampling based algorithms represent the configuration space with a roadmap or build a tree, generated by randomly sampling states in the configuration space. Some of the notable sampling-based algorithms are: Rapidly exploring Random Tree (RRT) RRT Star (RRT*) Informed RRT Star Batch Informed Trees Star (BIT*) Additional References For a better understanding of the path planning problem refer here . Understand configuration spaces from this video .","title":"Introduction to Path Planning in Robotics"},{"location":"automation/PathPlanners/intro/#path-planning-in-robotics","text":"","title":"Path Planning in Robotics"},{"location":"automation/PathPlanners/intro/#what-is-a-path","text":"Path, as the name suggests is a set of waypoints which a Robot is expected to travel. There can be many criterions for deciding a path that the Robot should follow. Various optimisations, checks are made before deciding an optimial path.","title":"What is a path?"},{"location":"automation/PathPlanners/intro/#why-planning-is-important-for-autonomous-robots","text":"Path planning is one of the most important primitives for autonomous mobile robots. The ability to be able to travel on its own by finding a collision free, optimal path is an important aspect of making robots autonomous","title":"Why Planning is important for Autonomous Robots?"},{"location":"automation/PathPlanners/intro/#path-planning-for-autonomous-robots","text":"Path planning, as illustrated above is an important aspect of autonomous robots. There are various methods how a path is planned. There are various algorithms on path planning. Some of the common features of path planners are: 1. Given a start and a goal position(or pose), give out a set of states(positions or velocities) that the robot should take to reach the goal from start. 2. The path generated should be collision free with the obstacles in the environment. 3. Generally the path generated should optimise some hueristic(or parameter). 4. The path generated should be traversable by a robot given its dynamics.","title":"Path planning for Autonomous Robots"},{"location":"automation/PathPlanners/intro/#path-planning-algorithms","text":"The problem to find an optimal path has been studied since many decades. There are many algorithms that are graph-based , sampling-based . Each branch follows a particular approach to solve the path planning problem.","title":"Path Planning algorithms"},{"location":"automation/PathPlanners/intro/#1-graph-based-algorithms","text":"Graph based algorithms overlay a topological graph on a robots configurational space and perform search for an optimal path. Some of the notable graph-based algorithms are: Dijkstra\u2019s Algorithm A-Star (A*) D-Star (D*)","title":"1. Graph based algorithms:"},{"location":"automation/PathPlanners/intro/#2-sampling-based-algorithms","text":"Sampling based algorithms represent the configuration space with a roadmap or build a tree, generated by randomly sampling states in the configuration space. Some of the notable sampling-based algorithms are: Rapidly exploring Random Tree (RRT) RRT Star (RRT*) Informed RRT Star Batch Informed Trees Star (BIT*)","title":"2. Sampling based algorithms:"},{"location":"automation/PathPlanners/intro/#additional-references","text":"For a better understanding of the path planning problem refer here . Understand configuration spaces from this video .","title":"Additional References"},{"location":"automation/ROS/ros/","text":"Getting Started with Robot Operating System (ROS)\u201d 1. What is ROS? For someone completely new to ROS, the best way to think about it is a collection of tools and frameworks which make automating robotics projects much easier. Every ROS project has a certain structure which you have to follow. Your job would be to fill in the automation code along defining how the different parts of your code are communicating with one another. Once this is done, the underlying ROS framework takes care of the actual networking and connections. ROS also has the advantage of having a large open source community with tons of packages. This means you have a lot of prewritten code to help with your project and you don\u2019t have to start from scratch. Don\u2019t worry if you are still confused, you will start to get a better understanding with some hands on experience. \u200bTo get a better understanding of what ROS is and why it exists, checkout out these videos (\u200b 1 \u200b, 2 ). A ROS system can be visualized as a graph where all the vertices are \u200bnodes and the edges between them are known as \u200btopics. In simple terms nodes are programs that perform a particular task and send out/receive data in the form of messages. These messages are exchanged between two nodes over the topic (edge) connecting them. An example of a typical ROS system is given in the figure to the left wherein \u201crobot\u201d, \u201claser\u201d, \u201cmap\u201d, \u201clocalisation\u201d and \u201cplanner\u201d are the nodes and the arrows connecting the nodes are the topics. An arrow \u200b from A to B indicates that the topic carries messages from node \u200bA to node B. 2. Reference Material While we have tried our best to provide a concise introduction to the basic concepts in this document, there are a lot of other much more thorough and complete resources that you should follow. This document can be treated more as a reference guide with some useful tips for beginners. The two most useful resources you can go through are - Programming Robots with ROS :\u200b A Practical Introduction to the Robot Operating System by Morgan Quigley. ROSwiki\u200b tutorials : The official ROS tutorials . Both of these have detailed implementation guides on the basic concepts. The ROSwiki is more concise while the book goes into more detail. We strongly recommend that you go through the first 4 chapters of the book and try out all the implementation examples yourselves. Along with these you can check out The Construct youtube \u200bvideos\u200b. 3. Basic Concepts Now let\u2019s get familiar with some very commonly used terms in ROS development. Along with the following introduction you should go through \u200b Chapter 1 and 2 \u200b of Morgan Quigley for in depth explanation and examples. Catkin: Catkin is the build system used for ROS. This means that after you have written all your code, defined your message files etc, you will run catkin to join everything together and compile any dependencies you have. To build packages you must have a catkin workspace where all your projects are contained. You will have to use it to \u200b build \u200b not only yours but any other packages that may be in your workspace. Click \u200b here \u200b to learn more about catkin. A catkin workspace or package can be built running either of these two commands : catkin_make or catkin build in the root of your catkin workspace. Note : The command used for building a workspace should be consistent everytime, i.e. if the workspace was built using catkin_make the very first time while initializing the workspace, all the subsequent builds should be done using catkin_make. To change the method of build in a pre existing workspace, you can use the command catkin clean which will clear everything except the source space (src folder) of the workspace. It can then be rebuilt using the desired command. Colcon: Colcon is another build system just like catkin. It comes with a vast array of features which can be used to organise your workspace. Similar to catkin, to build a workspace, you need to run colcon build in the root of the folder your workspace. You can check out the documentation of colcon to explore more features. Workspace: \u200bA ROS workspace is basically a directory with a certain hierarchy wherein all your sets of related ROS codes live. A workspace contains packages which in turn contain the code for nodes amongst other things. You can have multiple workspaces on your computer but work in only one at a time. Follow this \u200b tutorial in order to set up your own catkin workspace. After following the steps in the above tutorial, upon entering your workspace directory, you will see three directories: \u200b build , \u200b devel \u200band \u200b src . ROS Package: \u200b All the codes and software in ROS is organised in the form of packages. A package may contain ROS Nodes, libraries used in those codes, message and service definitions and all the dependencies. Follow \u200b this \u200b tutorial to know how to create a ROS package. (Note: Follow the \u2018catkin\u2019 way instead of \u2018rosbuild\u2019). After creating the package you\u2019ll see two files \u200bCMakeLists.txt and package.xml. We\u2019ll be using (editing) these files many times as we proceed to work with ROS. Apart from these files there is a directory \u201csrc\u201d. This is the place where the code for ROS nodes of the package lives (as mentioned before, nodes are nothing but programs that perform specific tasks). Once you have created your ROS package you have to build it so that you can use it. Follow \u200b this \u200b tutorial to see how to build your package. ROS Nodes and Packages: A \u200bnode is an executable file (could be python or C++) which performs a specific task and communicates with other nodes through \u200b topics. \u200bTwo main ways this is done is through publisher-subscriber relationship or services. All of the programming involved in creating a ROS based project is done while writing these nodes. Topics are\u200b the channels over which the messages of different kinds are transmitted between nodes, read \u200b this \u200b wiki to know more. ROS messages have to be specially defined for each user defined topic. Apart from the standard message types that come with ROS like \u200bstring, int32, etc. you can also define your custom message types in ROS for custom uses. Refer to parts 2 and 3 this \u200b tutorial to see how you can define and use a custom message type. Note: A single node can simultaneously act as a subscriber to one topic and a publisher of another topic and a server for one service and the client for another. Publisher - Subscriber Model: \u200bThis is a model through which two nodes can exchange data in the form of messages asynchronously, usually used when a one way stream of information is involved. For example, suppose you are developing a self-driving car and you have a node which processes the video feed from a camera to detect street signs. Whenever it detects a sign, it needs to communicate its type and distance from the car to another node which will use this information to control the speed of the car. In this scenario your sign detection node will be a publisher which publishes data about the signs it detects to a specific topic, say signs. \u200bYour controller node will be a subscriber which will subscribe to the \u200b signs \u200b topic and perform a certain task whenever it receives a message on this topic. Publisher: The publisher object of a ROS node publishes the data in the form of messages over a topic. There is a particular rate (which the user defines) at which the messages get published. Subscriber: The data published by the publisher of one ROS node can be received or \u2018subscribed\u2019 through the Subscriber object of a ROS node. The Subscriber object subscribes to the topic over which any publisher publishes the messages. Every Subscriber object is associated with a callback function which gets called everytime a message is published over the topic. You can check out how to implement a basic server-client for C++\u200b or \u200b pytho\u200bn in the ROS wiki or \u200bChapter 3\u200b of Morgan Quigley. Services: Another common mode of communication, especially suited when there is a transaction style relationship between the two nodes is the service - consisting of a server and a client . For example consider in your self driving car, you have one node to control the movement of the car and another to plan an optimal route to your destination. In such a scenario, the main control node would be the \u200b client \u200bfor the route planning \u200b server . This means that whenever the controller requires a route to be planned, supposed it finds out the route is blocked up ahead, then it would send a request to the server. This request would consist of the current location, the destination as well as any preferences the controller might have (like faster/more comfortable). The server would then compute an optimal route and return it to the server as the response. Client: \u200bThis is the node which sends requests to a server. In the client code, you can create a special function which acts as a proxy between the client and server. Whenever you call the function, it sends a request to the server with the arguments passed to it as parameters. Server: \u200bThis node constantly monitors for requests from the client. Whenever it receives one, it carries out the required task independently of the client and sends back the response when the task is complete. You can check out how to implement a basic server-client for C++\u200b or \u200bpython \u200b in the ROS wiki or Chapter 4 \u200b of Morgan Quigley. 4. Getting things running Getting a complete ROS system up and running requires a bit more work than executing a single file. Check out \u200b Chapter 20 of Morgan Quigley for more detailed explanation as well as examples for all of the following tools. ROS Master: Before running the functional nodes in your system, you should first understand ROS Master. This can be visualised as a central server to which all nodes are connected by default. It allows any node to look up information about any other node. This is essential for connecting nodes within the system. For eg. when a node (A) needs to subscribe to a topic published by another node (B), it will get the network address of node B from ROS Master. As you might guess, a running ROS Master is necessary for every ROS system since, without it, the nodes won\u2019t be able to connect with each other. Thus whenever you are setting up your system of nodes the first command must run in the terminal is \u200b roscore which initializes ROS Master. The ROS wiki has a section on ROS Master \u200b here \u200b or you can check out\u200b Chapter 2 \u200bof Morgan Quigley. rosrun: Once you start the ROS Master, you can now start your own ROS nodes. For this ROS has a special command called rosrun which lets you run the executable files for your node from anywhere. The format for rosrun is - rosrun <package_name> <executable_name>.py (Replace and appropriately) A note on node file permissions: If using python, before attempting to run any ROS nodes that you have written, make sure that you have given executable permission to the code files. For more info on linux file permission look \u200b here\u200b . The command to do this is - chmod u+x <executable_name>.py (Replace appropriately) A note on multiple terminal windows: Whenever you run \u200b roscore\u200b or your own ROS node, it will hold the terminal until it is killed. So if you are running multiple nodes, you will need to run each one in a separate terminal window (\u200b terminator \u200b to your rescue!). A note on the tab key in terminal: * Typing out long commands into the terminal can get tedious. So ros has a handy capability of completing your commands for you. Whenever you are using \u200b rosrun\u200b or roslaunch\u200b, you can type out the first few letters in the package name and then press the Tab key* on your keyboard. At this point, the package name will be autocomplete, saving you a lot of typing. Try it out, this works with other terminal commands too! roslaunch: ROS projects can involve a lot of nodes and launching them one by one can be a hassle. roslaunch is a command which lets you launch a specific set of nodes at once in a single terminal by using launch-files. These files usually contain a list of nodes and other related info and are generally stored in the \u2018launch\u2019 directory inside a package. Follow this tutorial to learn how to make a launch file. roscd: roscd is a command line tool which allows you to navigate or \u2018cd\u2019 (change directory) to (in command line terms) a package without knowing its exact path. Note: The workspace in which the package is present needs to be sourced. E.g. If you wish to navigate into the \u2018turtlebot3_gazebo\u2019 package you\u2019ll just type the following command in the terminal: roscd turtlebot3_gazebo rqt_graph: Once you have your system running, you can obtain a diagram along with other details of the system by running the rqt_graph command in another terminal window.","title":"Getting Started with ROS"},{"location":"automation/ROS/ros/#getting-started-with-robot-operating-system-ros","text":"","title":"Getting Started with Robot Operating System (ROS)\""},{"location":"automation/ROS/ros/#1-what-is-ros","text":"For someone completely new to ROS, the best way to think about it is a collection of tools and frameworks which make automating robotics projects much easier. Every ROS project has a certain structure which you have to follow. Your job would be to fill in the automation code along defining how the different parts of your code are communicating with one another. Once this is done, the underlying ROS framework takes care of the actual networking and connections. ROS also has the advantage of having a large open source community with tons of packages. This means you have a lot of prewritten code to help with your project and you don\u2019t have to start from scratch. Don\u2019t worry if you are still confused, you will start to get a better understanding with some hands on experience. \u200bTo get a better understanding of what ROS is and why it exists, checkout out these videos (\u200b 1 \u200b, 2 ). A ROS system can be visualized as a graph where all the vertices are \u200bnodes and the edges between them are known as \u200btopics. In simple terms nodes are programs that perform a particular task and send out/receive data in the form of messages. These messages are exchanged between two nodes over the topic (edge) connecting them. An example of a typical ROS system is given in the figure to the left wherein \u201crobot\u201d, \u201claser\u201d, \u201cmap\u201d, \u201clocalisation\u201d and \u201cplanner\u201d are the nodes and the arrows connecting the nodes are the topics. An arrow \u200b from A to B indicates that the topic carries messages from node \u200bA to node B.","title":"1. What is ROS?"},{"location":"automation/ROS/ros/#2-reference-material","text":"While we have tried our best to provide a concise introduction to the basic concepts in this document, there are a lot of other much more thorough and complete resources that you should follow. This document can be treated more as a reference guide with some useful tips for beginners. The two most useful resources you can go through are - Programming Robots with ROS :\u200b A Practical Introduction to the Robot Operating System by Morgan Quigley. ROSwiki\u200b tutorials : The official ROS tutorials . Both of these have detailed implementation guides on the basic concepts. The ROSwiki is more concise while the book goes into more detail. We strongly recommend that you go through the first 4 chapters of the book and try out all the implementation examples yourselves. Along with these you can check out The Construct youtube \u200bvideos\u200b.","title":"2. Reference Material"},{"location":"automation/ROS/ros/#3-basic-concepts","text":"Now let\u2019s get familiar with some very commonly used terms in ROS development. Along with the following introduction you should go through \u200b Chapter 1 and 2 \u200b of Morgan Quigley for in depth explanation and examples. Catkin: Catkin is the build system used for ROS. This means that after you have written all your code, defined your message files etc, you will run catkin to join everything together and compile any dependencies you have. To build packages you must have a catkin workspace where all your projects are contained. You will have to use it to \u200b build \u200b not only yours but any other packages that may be in your workspace. Click \u200b here \u200b to learn more about catkin. A catkin workspace or package can be built running either of these two commands : catkin_make or catkin build in the root of your catkin workspace. Note : The command used for building a workspace should be consistent everytime, i.e. if the workspace was built using catkin_make the very first time while initializing the workspace, all the subsequent builds should be done using catkin_make. To change the method of build in a pre existing workspace, you can use the command catkin clean which will clear everything except the source space (src folder) of the workspace. It can then be rebuilt using the desired command. Colcon: Colcon is another build system just like catkin. It comes with a vast array of features which can be used to organise your workspace. Similar to catkin, to build a workspace, you need to run colcon build in the root of the folder your workspace. You can check out the documentation of colcon to explore more features. Workspace: \u200bA ROS workspace is basically a directory with a certain hierarchy wherein all your sets of related ROS codes live. A workspace contains packages which in turn contain the code for nodes amongst other things. You can have multiple workspaces on your computer but work in only one at a time. Follow this \u200b tutorial in order to set up your own catkin workspace. After following the steps in the above tutorial, upon entering your workspace directory, you will see three directories: \u200b build , \u200b devel \u200band \u200b src . ROS Package: \u200b All the codes and software in ROS is organised in the form of packages. A package may contain ROS Nodes, libraries used in those codes, message and service definitions and all the dependencies. Follow \u200b this \u200b tutorial to know how to create a ROS package. (Note: Follow the \u2018catkin\u2019 way instead of \u2018rosbuild\u2019). After creating the package you\u2019ll see two files \u200bCMakeLists.txt and package.xml. We\u2019ll be using (editing) these files many times as we proceed to work with ROS. Apart from these files there is a directory \u201csrc\u201d. This is the place where the code for ROS nodes of the package lives (as mentioned before, nodes are nothing but programs that perform specific tasks). Once you have created your ROS package you have to build it so that you can use it. Follow \u200b this \u200b tutorial to see how to build your package. ROS Nodes and Packages: A \u200bnode is an executable file (could be python or C++) which performs a specific task and communicates with other nodes through \u200b topics. \u200bTwo main ways this is done is through publisher-subscriber relationship or services. All of the programming involved in creating a ROS based project is done while writing these nodes. Topics are\u200b the channels over which the messages of different kinds are transmitted between nodes, read \u200b this \u200b wiki to know more. ROS messages have to be specially defined for each user defined topic. Apart from the standard message types that come with ROS like \u200bstring, int32, etc. you can also define your custom message types in ROS for custom uses. Refer to parts 2 and 3 this \u200b tutorial to see how you can define and use a custom message type. Note: A single node can simultaneously act as a subscriber to one topic and a publisher of another topic and a server for one service and the client for another. Publisher - Subscriber Model: \u200bThis is a model through which two nodes can exchange data in the form of messages asynchronously, usually used when a one way stream of information is involved. For example, suppose you are developing a self-driving car and you have a node which processes the video feed from a camera to detect street signs. Whenever it detects a sign, it needs to communicate its type and distance from the car to another node which will use this information to control the speed of the car. In this scenario your sign detection node will be a publisher which publishes data about the signs it detects to a specific topic, say signs. \u200bYour controller node will be a subscriber which will subscribe to the \u200b signs \u200b topic and perform a certain task whenever it receives a message on this topic. Publisher: The publisher object of a ROS node publishes the data in the form of messages over a topic. There is a particular rate (which the user defines) at which the messages get published. Subscriber: The data published by the publisher of one ROS node can be received or \u2018subscribed\u2019 through the Subscriber object of a ROS node. The Subscriber object subscribes to the topic over which any publisher publishes the messages. Every Subscriber object is associated with a callback function which gets called everytime a message is published over the topic. You can check out how to implement a basic server-client for C++\u200b or \u200b pytho\u200bn in the ROS wiki or \u200bChapter 3\u200b of Morgan Quigley. Services: Another common mode of communication, especially suited when there is a transaction style relationship between the two nodes is the service - consisting of a server and a client . For example consider in your self driving car, you have one node to control the movement of the car and another to plan an optimal route to your destination. In such a scenario, the main control node would be the \u200b client \u200bfor the route planning \u200b server . This means that whenever the controller requires a route to be planned, supposed it finds out the route is blocked up ahead, then it would send a request to the server. This request would consist of the current location, the destination as well as any preferences the controller might have (like faster/more comfortable). The server would then compute an optimal route and return it to the server as the response. Client: \u200bThis is the node which sends requests to a server. In the client code, you can create a special function which acts as a proxy between the client and server. Whenever you call the function, it sends a request to the server with the arguments passed to it as parameters. Server: \u200bThis node constantly monitors for requests from the client. Whenever it receives one, it carries out the required task independently of the client and sends back the response when the task is complete. You can check out how to implement a basic server-client for C++\u200b or \u200bpython \u200b in the ROS wiki or Chapter 4 \u200b of Morgan Quigley.","title":"3. Basic Concepts"},{"location":"automation/ROS/ros/#4-getting-things-running","text":"Getting a complete ROS system up and running requires a bit more work than executing a single file. Check out \u200b Chapter 20 of Morgan Quigley for more detailed explanation as well as examples for all of the following tools. ROS Master: Before running the functional nodes in your system, you should first understand ROS Master. This can be visualised as a central server to which all nodes are connected by default. It allows any node to look up information about any other node. This is essential for connecting nodes within the system. For eg. when a node (A) needs to subscribe to a topic published by another node (B), it will get the network address of node B from ROS Master. As you might guess, a running ROS Master is necessary for every ROS system since, without it, the nodes won\u2019t be able to connect with each other. Thus whenever you are setting up your system of nodes the first command must run in the terminal is \u200b roscore which initializes ROS Master. The ROS wiki has a section on ROS Master \u200b here \u200b or you can check out\u200b Chapter 2 \u200bof Morgan Quigley. rosrun: Once you start the ROS Master, you can now start your own ROS nodes. For this ROS has a special command called rosrun which lets you run the executable files for your node from anywhere. The format for rosrun is - rosrun <package_name> <executable_name>.py (Replace and appropriately) A note on node file permissions: If using python, before attempting to run any ROS nodes that you have written, make sure that you have given executable permission to the code files. For more info on linux file permission look \u200b here\u200b . The command to do this is - chmod u+x <executable_name>.py (Replace appropriately) A note on multiple terminal windows: Whenever you run \u200b roscore\u200b or your own ROS node, it will hold the terminal until it is killed. So if you are running multiple nodes, you will need to run each one in a separate terminal window (\u200b terminator \u200b to your rescue!). A note on the tab key in terminal: * Typing out long commands into the terminal can get tedious. So ros has a handy capability of completing your commands for you. Whenever you are using \u200b rosrun\u200b or roslaunch\u200b, you can type out the first few letters in the package name and then press the Tab key* on your keyboard. At this point, the package name will be autocomplete, saving you a lot of typing. Try it out, this works with other terminal commands too! roslaunch: ROS projects can involve a lot of nodes and launching them one by one can be a hassle. roslaunch is a command which lets you launch a specific set of nodes at once in a single terminal by using launch-files. These files usually contain a list of nodes and other related info and are generally stored in the \u2018launch\u2019 directory inside a package. Follow this tutorial to learn how to make a launch file. roscd: roscd is a command line tool which allows you to navigate or \u2018cd\u2019 (change directory) to (in command line terms) a package without knowing its exact path. Note: The workspace in which the package is present needs to be sourced. E.g. If you wish to navigate into the \u2018turtlebot3_gazebo\u2019 package you\u2019ll just type the following command in the terminal: roscd turtlebot3_gazebo rqt_graph: Once you have your system running, you can obtain a diagram along with other details of the system by running the rqt_graph command in another terminal window.","title":"4. Getting things running"},{"location":"automation/ROS/ros_p2/","text":"ROS Parameters and Parameter Server Parameter server is a collection of values or parameters that can be retrieved or modified by the nodes during runtime upon requests through command prompt, nodes or launch files. Parameters are intended to be static, globally available values like integers, floats, strings and boolean values and can be stored independently or within a YAML file. Parameters are meant to be gloablly viewable so nodes can easily inspect the configuration state of the system and modify if necessary. Accessing and setting Parameters Via command line Parameters can be accessed, modified or deleted using the rosparam command line utility in the rosbash suite of terminal commands. 1) To list all the parameters : rosparam list Or to list all the parameters in a specific namespace : rosparam list </namespace> 2) To assign a value to an already existing parameter or to set a new one : rosparam set <parameter_name> <parameter_value> Note : You can also load the parameters into the parameter server from a YAML file using < br /> ``` rosparam load < filename > < namepsace > ``` 3) To get/read a parameter value : rosparam get <parameter_name> Note : You can also dump/save the parameters into a YAML file from parameter server using rosparam dump <filename> <namespace> For more insights regarding the rosparam tool refer to this link. Via the rospy API library Parameters from the parameter server can be accessed and modified using rospy API library. This is generally used when the parameters are to be used by a node during the runtime. Refer this link for more imformation on handling parameters using rospy API library. Via launch files Parameters can be set, created and loaded into the parameter server while creating launch files. Refer to this link ROSWiki for more information on handling parameters in launch files. Following links can be referred to for more insights on parameters and parameter server 1 , 2 , 3","title":"ROS Parameters"},{"location":"automation/ROS/ros_p2/#ros-parameters-and-parameter-server","text":"Parameter server is a collection of values or parameters that can be retrieved or modified by the nodes during runtime upon requests through command prompt, nodes or launch files. Parameters are intended to be static, globally available values like integers, floats, strings and boolean values and can be stored independently or within a YAML file. Parameters are meant to be gloablly viewable so nodes can easily inspect the configuration state of the system and modify if necessary.","title":"ROS Parameters and Parameter Server"},{"location":"automation/ROS/ros_p2/#accessing-and-setting-parameters","text":"","title":"Accessing and setting Parameters"},{"location":"automation/ROS/ros_p2/#via-command-line","text":"Parameters can be accessed, modified or deleted using the rosparam command line utility in the rosbash suite of terminal commands. 1) To list all the parameters : rosparam list Or to list all the parameters in a specific namespace : rosparam list </namespace> 2) To assign a value to an already existing parameter or to set a new one : rosparam set <parameter_name> <parameter_value> Note : You can also load the parameters into the parameter server from a YAML file using < br /> ``` rosparam load < filename > < namepsace > ``` 3) To get/read a parameter value : rosparam get <parameter_name> Note : You can also dump/save the parameters into a YAML file from parameter server using rosparam dump <filename> <namespace> For more insights regarding the rosparam tool refer to this link.","title":"Via command line"},{"location":"automation/ROS/ros_p2/#via-the-rospy-api-library","text":"Parameters from the parameter server can be accessed and modified using rospy API library. This is generally used when the parameters are to be used by a node during the runtime. Refer this link for more imformation on handling parameters using rospy API library.","title":"Via the rospy API library"},{"location":"automation/ROS/ros_p2/#via-launch-files","text":"Parameters can be set, created and loaded into the parameter server while creating launch files. Refer to this link ROSWiki for more information on handling parameters in launch files. Following links can be referred to for more insights on parameters and parameter server 1 , 2 , 3","title":"Via launch files"},{"location":"automation/ROS/setting_up/","text":"Preparing your Development Environment One of the most essential and widely used tools for robot automation in Robot Operating System or ROS . This section will guide you through how to setup ROS and other tools on your computer. 1. Operating System Robotics Development relies heavily on Linux . We recommend using Ubuntu 18.04 since it is the most widely used and supported variant of Linux. If you already have Ubuntu 16.04, this is also OK, although for versions older than this we recommend upgrading to 18.04. For those who currently have Windows as the only OS on their machine, the best way to start using Ubuntu would be to dual boot . Here is a guide on how to do this . For MacOS users, dual booting is an option but we recommend using up a virtual machine. If you are unable to dual boot for any reason, you can try setting up a virtual machine . The first step in this is to install a virtualisation software. For Windows you can use either VirtualBox (free) or Vmware Workstation and for MacOS either VirtualBox (free), Vmware Fusion or Parallels. After getting one of the above, follow the instructions given here (skip ahead to the Download Image section). After completing the given procedure you will be equipped with all the basic tools required for Robotics including ROS, catkin and git. In the unfortunate case that the above options do not work , for Windows users there is still a way - WSL . Do be warned however, this path is fraught with frustration and much debugging. Only continue if you have exhausted other options. For a guide on setting up WSL for ROS, look here . For those whom none of the above are possible, consider using the online browser based ROS Development Studio . Keep in mind that it has a limited access time per week and performance may be questionable. 2. Robot Operating System (ROS) Note that this part is unnecessary if you followed the given instructions to set up a VM. For everyone else, this part is essential . Different versions of Ubuntu need different variants of ROS. Instructions given below - \u2794 Ubuntu 18.04 : ROS Melodic \u2794 Ubuntu 16.04 : ROS Kinetic 3. Useful tools to make your life easier Git\u200b : Fundamental tool in open source software development. Used for version control and sharing of code. sudo apt install git Terminator \u200b : Terminal Emulator useful for having multiple terminals in a window. sudo apt install terminator Code Editors : A good editor can go a long way in boosting productivity. We recommend \u200b VSCode \u200b which has plugins for python and ROS. A comprehensive guide for how to integrate ROS into your favourite IDE can be found \u200bhere \u200b. 4. ROS Packages You can install already developed ROS packages using the apt (package manager for Ubuntu). Replace name of the ROS package sudo apt install ros- $ROS_DISTRO -<package_name> For example Turtlebot is one of the most commonly used ground bots for simulation purposes. You can install Turtlebot and it\u2019s related packages using the following command - sudo apt install ros- $ROS_DISTRO -turtlebot3-* 5. Tips for getting things to work + some helpful facts Make a habit of running sudo apt update before installing packages in linux. For the uninitiated, your bashrc file is the configuration file for your bash terminal (the thing you type commands into). It\u2019s usually located in your home directory at ~/.bashrc For more info, check out this . Don\u2019t forget to source the workspace you want to use. For convenience you can source the workspace on startup by editing your .bashrc file to include the following line. Replace with the path of your workspace source <workspace_path>/devel/setup.bash You cannot source two workspaces at the same time. Anaconda and ROS cannot be used in the same environment because they have a conflicting python path. As given here , to deal with this, edit your bashrc file by commenting the anaconda python path like this - // export PATH = \"/home//anaconda3/bin: $PATH \" Use python pip to install python dependencies. Anaconda should be avoided.","title":"Setting Up"},{"location":"automation/ROS/setting_up/#preparing-your-development-environment","text":"One of the most essential and widely used tools for robot automation in Robot Operating System or ROS . This section will guide you through how to setup ROS and other tools on your computer.","title":"Preparing your Development Environment"},{"location":"automation/ROS/setting_up/#1-operating-system","text":"Robotics Development relies heavily on Linux . We recommend using Ubuntu 18.04 since it is the most widely used and supported variant of Linux. If you already have Ubuntu 16.04, this is also OK, although for versions older than this we recommend upgrading to 18.04. For those who currently have Windows as the only OS on their machine, the best way to start using Ubuntu would be to dual boot . Here is a guide on how to do this . For MacOS users, dual booting is an option but we recommend using up a virtual machine. If you are unable to dual boot for any reason, you can try setting up a virtual machine . The first step in this is to install a virtualisation software. For Windows you can use either VirtualBox (free) or Vmware Workstation and for MacOS either VirtualBox (free), Vmware Fusion or Parallels. After getting one of the above, follow the instructions given here (skip ahead to the Download Image section). After completing the given procedure you will be equipped with all the basic tools required for Robotics including ROS, catkin and git. In the unfortunate case that the above options do not work , for Windows users there is still a way - WSL . Do be warned however, this path is fraught with frustration and much debugging. Only continue if you have exhausted other options. For a guide on setting up WSL for ROS, look here . For those whom none of the above are possible, consider using the online browser based ROS Development Studio . Keep in mind that it has a limited access time per week and performance may be questionable.","title":"1. Operating System"},{"location":"automation/ROS/setting_up/#2-robot-operating-system-ros","text":"Note that this part is unnecessary if you followed the given instructions to set up a VM. For everyone else, this part is essential . Different versions of Ubuntu need different variants of ROS. Instructions given below - \u2794 Ubuntu 18.04 : ROS Melodic \u2794 Ubuntu 16.04 : ROS Kinetic","title":"2. Robot Operating System (ROS)"},{"location":"automation/ROS/setting_up/#3-useful-tools-to-make-your-life-easier","text":"Git\u200b : Fundamental tool in open source software development. Used for version control and sharing of code. sudo apt install git Terminator \u200b : Terminal Emulator useful for having multiple terminals in a window. sudo apt install terminator Code Editors : A good editor can go a long way in boosting productivity. We recommend \u200b VSCode \u200b which has plugins for python and ROS. A comprehensive guide for how to integrate ROS into your favourite IDE can be found \u200bhere \u200b.","title":"3. Useful tools to make your life easier"},{"location":"automation/ROS/setting_up/#4-ros-packages","text":"You can install already developed ROS packages using the apt (package manager for Ubuntu). Replace name of the ROS package sudo apt install ros- $ROS_DISTRO -<package_name> For example Turtlebot is one of the most commonly used ground bots for simulation purposes. You can install Turtlebot and it\u2019s related packages using the following command - sudo apt install ros- $ROS_DISTRO -turtlebot3-*","title":"4. ROS Packages"},{"location":"automation/ROS/setting_up/#5-tips-for-getting-things-to-work-some-helpful-facts","text":"Make a habit of running sudo apt update before installing packages in linux. For the uninitiated, your bashrc file is the configuration file for your bash terminal (the thing you type commands into). It\u2019s usually located in your home directory at ~/.bashrc For more info, check out this . Don\u2019t forget to source the workspace you want to use. For convenience you can source the workspace on startup by editing your .bashrc file to include the following line. Replace with the path of your workspace source <workspace_path>/devel/setup.bash You cannot source two workspaces at the same time. Anaconda and ROS cannot be used in the same environment because they have a conflicting python path. As given here , to deal with this, edit your bashrc file by commenting the anaconda python path like this - // export PATH = \"/home//anaconda3/bin: $PATH \" Use python pip to install python dependencies. Anaconda should be avoided.","title":"5. Tips for getting things to work + some helpful facts"},{"location":"electronics/intro/","text":"Introduction","title":"Introduction"},{"location":"electronics/intro/#introduction","text":"","title":"Introduction"},{"location":"electronics/Basic_Electronic_Components/breadboard/","text":"Breadboards The breadboard is the most fundamental tool for electronics prototyping. They are great for creating temporary circuits and require absolutely no soldering. How to use a breadboard A solderless breadboard consists of several holes, where wires or leads of electrical can be inserted. Each row of 5 holes is electrically connected by metal clips hidden underneath the surface. Thus, one can connect two components by inserting them into holes of the same row. ICs can be inserted across the central ridge, and connections made as shown below. On either side of the breadboard are the power rails . Each power rail has two long electrically connected rows, and are often connected to batteries or some other power source. For a more extensive breadboard tutorial, check out this sparkfun guide . Tips for breadboard usage To make breadboard connections, DuPont style jumper wires or single core 22AWG wire is most convenient. Avoid multistranded wire. Keep wires and wire leads as short as possible, to avoid clutter and make troubleshooting easier.","title":"Breadboard"},{"location":"electronics/Basic_Electronic_Components/breadboard/#breadboards","text":"The breadboard is the most fundamental tool for electronics prototyping. They are great for creating temporary circuits and require absolutely no soldering.","title":"Breadboards"},{"location":"electronics/Basic_Electronic_Components/breadboard/#how-to-use-a-breadboard","text":"A solderless breadboard consists of several holes, where wires or leads of electrical can be inserted. Each row of 5 holes is electrically connected by metal clips hidden underneath the surface. Thus, one can connect two components by inserting them into holes of the same row. ICs can be inserted across the central ridge, and connections made as shown below. On either side of the breadboard are the power rails . Each power rail has two long electrically connected rows, and are often connected to batteries or some other power source. For a more extensive breadboard tutorial, check out this sparkfun guide .","title":"How to use a breadboard"},{"location":"electronics/Basic_Electronic_Components/breadboard/#tips-for-breadboard-usage","text":"To make breadboard connections, DuPont style jumper wires or single core 22AWG wire is most convenient. Avoid multistranded wire. Keep wires and wire leads as short as possible, to avoid clutter and make troubleshooting easier.","title":"Tips for breadboard usage"},{"location":"electronics/Development_Boards/Arduino/","text":"Arduino The Arduino is basically a very accessible and easy to program microcontroller. Unlike other microcontrollers, which need knowledge of registers and ports, the Arduino is programmed by a very basic C-derived language. This video explains what an Arduino is, what it is capable of, and the numerous projects one can use it for. Arduino Board Layout The above diagram shows an Arduino UNO board with all the parts labelled and explained below: USB Port: Arduino can be powered by connecting it to your computer using a USB cable. It is also used for uploading code and communicating via the serial port. Power Jack: Used to power an arduino directly from a wall adaptor. Voltage Regulator: Controls and stabilises the voltage used by the Arduino and its components. Crystal Oscillator: A microcontroller is a clock based device. The crystal oscillator present on the arduino generates a clock of frequency 16MHz. Reset controllers: Resetting the arduino board starts the execution of a program from the beginning. Arduino can be reset in 2 ways : by pressing the reset button (17) and sending a 0V signal to the RESET pin (5). 3.3V power 5V power GND (0V) VIN: This pin can be used to power the arduino board from an external power source, from 7-20V. Analog Pins: These pins (labeled A0-A5) can be used to read continuous analog values (between 0 and 5V). They are often used to interface the Arduino with analog sensors. Main Microcontroller: This IC is the main microcontroller, that executes the code you program it with. ICSP Pin: Can be used to program the arduino board\u2019s firmware. For advanced users only. Power LED indicator: Indicates whether the board is powered up correctly. TX/RX LEDs: The TX/RX pins flash to indicate transfer/receival of serial data between the computer and Arduino. Digital I/O Pins: These pins can be programmed as input/output pins. When used as output, they can be set HIGH (+5V) or LOW (0V). Analog Reference(AREF): Can be used to set an external reference voltage(0-5V) as the upper limit for analog input pins. Reset Button: Pressing it causes the Arduino to restart its code. The Blink Sketch The Blink sketch is like the \u201cHello World\u201d program in the Arduino world. It simply consists of blinking the onboard LED (labeled \u2018L\u2019). No actual circuit connections are required! Code You can copy the code from here . How to code an Arduino in Arduino IDE Download and install Arduino Software (IDE) from here . The Integrated Development Environment (IDE) is a common coding environment for all arduino boards. Open the IDE and a new sketch will open up which would look like the image below. Sketch is just a name arduino uses for a program. Then just paste the entire code here. Now connect your Arduino UNO board to your PC using an A B USB cable and select the option \u201cArduino/Genuino Uno\u201d under Tools > Board menu. Also make sure to select the correct port through which the PC is connected to the board under Tools > Port menu. Click on the \u201ctick\u201d button in upper left corner to compile the code and check for errors. After resolving any and all errors click on the \u201carrow\u201d button next to it to upload the code to the board. After successful upload the Arduino Uno will start executing the code while drawing power from the PC through the USB cable. Explanation Every Arduino sketch must have two particular functions: void setup() The setup() function is called when a sketch starts and will only run once, after each powerup or reset of the Arduino board. void loop() This function does precisely what its name suggests, that is loops consecutively, allowing your program to change and respond. Whatever code you write inside loop() will keep running as long as the Arduino is receiving power. Let us examine the Blink sketch now, line by line. int led = 13 ; This line assigns a name to the pin that the LED is attached to, i.e. pin 13. Then we have the setup() function, which runs only once. It includes the following line. pinMode ( led , OUTPUT ); This tells the Arduino to configure that pin as an output. Then we have the following loop() function. void loop () { digitalWrite ( led , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( led , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } The digitalWrite() function tells a pin to either switch on (HIGH, or +5V) or off (LOW, or 0V). The delay() function tells the Arduino to wait for a specified number of milliseconds. Reading Analog Values The following circuit reads the voltage from a potentiometer and sends it via USB to the serial port. Schematic Code Copy the code from here and paste it into a new sketch in the Arduino IDE and upload the code to the board. After successful uploading open the serial monitor in the IDE by clicking on its button on top right corner. Trying varying the potentiometer\u2019s knob - you should see the stream of values of the serial monitor change. Explanation Whenever the serial port is to be used, it should be initialised with the following line inside void setup(). The 9600 refers to the communication speed in bits-per-second. Serial . begin ( 9600 ); The analogRead function reads the voltage at an analog pin and linearly converts it to a value between 0 and 1023. The Serial.println() function prints a variable to the serial monitor, followed by a newline (using Serial.print() to print data without the newline). The delay(1) is to limit the amount of data printed to the serial monitor. References For more lessons and material on Arduino, check out the QSTP - Introduction to Mechatronics , designed by ERC. For some more detailed tutorials do read the documentation of Arduino . For some video tutorials check out Jeremy Blum\u2019s playlist for Arduino. For more DIY project ideas and inspirations check out Great Scott\u2019s youtube channel. To read more about the projects made by people using Arduino, check out Arduino\u2019s blog as well.","title":"Arduino"},{"location":"electronics/Development_Boards/Arduino/#arduino","text":"The Arduino is basically a very accessible and easy to program microcontroller. Unlike other microcontrollers, which need knowledge of registers and ports, the Arduino is programmed by a very basic C-derived language. This video explains what an Arduino is, what it is capable of, and the numerous projects one can use it for.","title":"Arduino"},{"location":"electronics/Development_Boards/Arduino/#arduino-board-layout","text":"The above diagram shows an Arduino UNO board with all the parts labelled and explained below: USB Port: Arduino can be powered by connecting it to your computer using a USB cable. It is also used for uploading code and communicating via the serial port. Power Jack: Used to power an arduino directly from a wall adaptor. Voltage Regulator: Controls and stabilises the voltage used by the Arduino and its components. Crystal Oscillator: A microcontroller is a clock based device. The crystal oscillator present on the arduino generates a clock of frequency 16MHz. Reset controllers: Resetting the arduino board starts the execution of a program from the beginning. Arduino can be reset in 2 ways : by pressing the reset button (17) and sending a 0V signal to the RESET pin (5). 3.3V power 5V power GND (0V) VIN: This pin can be used to power the arduino board from an external power source, from 7-20V. Analog Pins: These pins (labeled A0-A5) can be used to read continuous analog values (between 0 and 5V). They are often used to interface the Arduino with analog sensors. Main Microcontroller: This IC is the main microcontroller, that executes the code you program it with. ICSP Pin: Can be used to program the arduino board\u2019s firmware. For advanced users only. Power LED indicator: Indicates whether the board is powered up correctly. TX/RX LEDs: The TX/RX pins flash to indicate transfer/receival of serial data between the computer and Arduino. Digital I/O Pins: These pins can be programmed as input/output pins. When used as output, they can be set HIGH (+5V) or LOW (0V). Analog Reference(AREF): Can be used to set an external reference voltage(0-5V) as the upper limit for analog input pins. Reset Button: Pressing it causes the Arduino to restart its code.","title":"Arduino Board Layout"},{"location":"electronics/Development_Boards/Arduino/#the-blink-sketch","text":"The Blink sketch is like the \u201cHello World\u201d program in the Arduino world. It simply consists of blinking the onboard LED (labeled \u2018L\u2019). No actual circuit connections are required!","title":"The Blink Sketch"},{"location":"electronics/Development_Boards/Arduino/#code","text":"You can copy the code from here .","title":"Code"},{"location":"electronics/Development_Boards/Arduino/#how-to-code-an-arduino-in-arduino-ide","text":"Download and install Arduino Software (IDE) from here . The Integrated Development Environment (IDE) is a common coding environment for all arduino boards. Open the IDE and a new sketch will open up which would look like the image below. Sketch is just a name arduino uses for a program. Then just paste the entire code here. Now connect your Arduino UNO board to your PC using an A B USB cable and select the option \u201cArduino/Genuino Uno\u201d under Tools > Board menu. Also make sure to select the correct port through which the PC is connected to the board under Tools > Port menu. Click on the \u201ctick\u201d button in upper left corner to compile the code and check for errors. After resolving any and all errors click on the \u201carrow\u201d button next to it to upload the code to the board. After successful upload the Arduino Uno will start executing the code while drawing power from the PC through the USB cable.","title":"How to code an Arduino in Arduino IDE"},{"location":"electronics/Development_Boards/Arduino/#explanation","text":"Every Arduino sketch must have two particular functions: void setup() The setup() function is called when a sketch starts and will only run once, after each powerup or reset of the Arduino board. void loop() This function does precisely what its name suggests, that is loops consecutively, allowing your program to change and respond. Whatever code you write inside loop() will keep running as long as the Arduino is receiving power. Let us examine the Blink sketch now, line by line. int led = 13 ; This line assigns a name to the pin that the LED is attached to, i.e. pin 13. Then we have the setup() function, which runs only once. It includes the following line. pinMode ( led , OUTPUT ); This tells the Arduino to configure that pin as an output. Then we have the following loop() function. void loop () { digitalWrite ( led , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( led , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } The digitalWrite() function tells a pin to either switch on (HIGH, or +5V) or off (LOW, or 0V). The delay() function tells the Arduino to wait for a specified number of milliseconds.","title":"Explanation"},{"location":"electronics/Development_Boards/Arduino/#reading-analog-values","text":"The following circuit reads the voltage from a potentiometer and sends it via USB to the serial port.","title":"Reading Analog Values"},{"location":"electronics/Development_Boards/Arduino/#schematic","text":"","title":"Schematic"},{"location":"electronics/Development_Boards/Arduino/#code_1","text":"Copy the code from here and paste it into a new sketch in the Arduino IDE and upload the code to the board. After successful uploading open the serial monitor in the IDE by clicking on its button on top right corner. Trying varying the potentiometer\u2019s knob - you should see the stream of values of the serial monitor change.","title":"Code"},{"location":"electronics/Development_Boards/Arduino/#explanation_1","text":"Whenever the serial port is to be used, it should be initialised with the following line inside void setup(). The 9600 refers to the communication speed in bits-per-second. Serial . begin ( 9600 ); The analogRead function reads the voltage at an analog pin and linearly converts it to a value between 0 and 1023. The Serial.println() function prints a variable to the serial monitor, followed by a newline (using Serial.print() to print data without the newline). The delay(1) is to limit the amount of data printed to the serial monitor.","title":"Explanation"},{"location":"electronics/Development_Boards/Arduino/#references","text":"For more lessons and material on Arduino, check out the QSTP - Introduction to Mechatronics , designed by ERC. For some more detailed tutorials do read the documentation of Arduino . For some video tutorials check out Jeremy Blum\u2019s playlist for Arduino. For more DIY project ideas and inspirations check out Great Scott\u2019s youtube channel. To read more about the projects made by people using Arduino, check out Arduino\u2019s blog as well.","title":"References"},{"location":"electronics/Development_Boards/STM32/","text":"Blue Pill (STM32F103C8T6) Introduction The STM32F103C8T6 (also known as \u2018STM32\u2019 or \u2018Blue Pill\u201d) is a cheap development board based on the ARM Cortex M3 microprocessor. This video by Great Scott can prove to be an introductory video to understand what it exactly is and how it can be used. Naming Convention of STM microcontrollers Parameter Meaning STM name of the manufacturer (STMicroelectronics) 32 32 bit ARM architecture F Foundation 1 Core (ARM Cortex M3) 03 Line (describes peripherals and speed) C 48 pins 8 64 KB flash memory T LQFP package (Low Profile Quad Flat Pack) 6 Operating Temperature Range (-40 \u00b0C to 85 \u00b0C) Technical Specifications of STM32 Parameter Meaning Architecture 32 bit ARM Cortex M3 Operating Voltage 2.7V to 3.6V CPU Frequency 72 MHz Number of GPIO pins 37 Number of PWM pins 12 Analog Input Pins 10 (12 bit resolution) I2C Peripherals 2 SPI Peripherals 2 CAN 2.0 Peripheral 1 Timers 3(16-bit), 1 Flash Memory 64KB RAM 20kB For more insights about the technical specifcations refer to the official datsheet and reference manual by STMicroelectronics. Pinout Programming STM32 1) Using STM32duino bootloader (Arduino IDE) You can program your STM32 development board using Arduino IDE, too. You will require FTDI (USB to UART converter) for this process. This tutorial explains the complete process. 2) Using Keil UVision and STM32CubeMX This is one step further than the last mentioned process and is more professional in terms of usage. You will require the softwares ARM\u2019s Keil Uvision and STM32CubeMX for this method of programming BluePill. You will also need the STLink/V2 which is a debugger cum programmer hardware provided by STMicroelectronics. These softwares provide a more sophisticated and professional programming environment for programming embedded systems. You may refer to this guide to know this method in detail.","title":"BluePill (STM32F103C8T6)"},{"location":"electronics/Development_Boards/STM32/#blue-pill-stm32f103c8t6","text":"","title":"Blue Pill (STM32F103C8T6)"},{"location":"electronics/Development_Boards/STM32/#introduction","text":"The STM32F103C8T6 (also known as \u2018STM32\u2019 or \u2018Blue Pill\u201d) is a cheap development board based on the ARM Cortex M3 microprocessor. This video by Great Scott can prove to be an introductory video to understand what it exactly is and how it can be used.","title":"Introduction"},{"location":"electronics/Development_Boards/STM32/#naming-convention-of-stm-microcontrollers","text":"Parameter Meaning STM name of the manufacturer (STMicroelectronics) 32 32 bit ARM architecture F Foundation 1 Core (ARM Cortex M3) 03 Line (describes peripherals and speed) C 48 pins 8 64 KB flash memory T LQFP package (Low Profile Quad Flat Pack) 6 Operating Temperature Range (-40 \u00b0C to 85 \u00b0C)","title":"Naming Convention of STM microcontrollers "},{"location":"electronics/Development_Boards/STM32/#technical-specifications-of-stm32","text":"Parameter Meaning Architecture 32 bit ARM Cortex M3 Operating Voltage 2.7V to 3.6V CPU Frequency 72 MHz Number of GPIO pins 37 Number of PWM pins 12 Analog Input Pins 10 (12 bit resolution) I2C Peripherals 2 SPI Peripherals 2 CAN 2.0 Peripheral 1 Timers 3(16-bit), 1 Flash Memory 64KB RAM 20kB For more insights about the technical specifcations refer to the official datsheet and reference manual by STMicroelectronics.","title":"Technical Specifications of STM32 "},{"location":"electronics/Development_Boards/STM32/#pinout","text":"","title":"Pinout"},{"location":"electronics/Development_Boards/STM32/#programming-stm32","text":"","title":"Programming STM32 "},{"location":"electronics/Development_Boards/STM32/#1-using-stm32duino-bootloader-arduino-ide","text":"You can program your STM32 development board using Arduino IDE, too. You will require FTDI (USB to UART converter) for this process. This tutorial explains the complete process.","title":"1) Using STM32duino bootloader (Arduino IDE)"},{"location":"electronics/Development_Boards/STM32/#2-using-keil-uvision-and-stm32cubemx","text":"This is one step further than the last mentioned process and is more professional in terms of usage. You will require the softwares ARM\u2019s Keil Uvision and STM32CubeMX for this method of programming BluePill. You will also need the STLink/V2 which is a debugger cum programmer hardware provided by STMicroelectronics. These softwares provide a more sophisticated and professional programming environment for programming embedded systems. You may refer to this guide to know this method in detail.","title":"2) Using Keil UVision and STM32CubeMX"},{"location":"electronics/Development_Boards/STM32vsArduinoUNO/","text":"Comparison between STM32F103C8T6 and Arduino UNO Parameter STM32F103C8T6 (Blue Pill) Arduino UNO Processor STM32F103C8T6 ATMega328P Operating Voltage 3.3V 5V CPU Speed 72 MHz 16 MHz Analog pins 10 8 Digital I/O or PWM 37 14 EEPROM/SRAM (KB) NA/20 1/2 Flash Memory 64/128 KB 32 KB USB Conector Micro Type B UART 3 1 SPI 2 1 I\u00b2C 2 1","title":"Arduino vs STM32"},{"location":"electronics/Development_Boards/STM32vsArduinoUNO/#comparison-between-stm32f103c8t6-and-arduino-uno","text":"Parameter STM32F103C8T6 (Blue Pill) Arduino UNO Processor STM32F103C8T6 ATMega328P Operating Voltage 3.3V 5V CPU Speed 72 MHz 16 MHz Analog pins 10 8 Digital I/O or PWM 37 14 EEPROM/SRAM (KB) NA/20 1/2 Flash Memory 64/128 KB 32 KB USB Conector Micro Type B UART 3 1 SPI 2 1 I\u00b2C 2 1","title":"Comparison between STM32F103C8T6 and Arduino UNO"},{"location":"mechanical/Forward%20and%20Inverse%20Kinematics/","text":"Forward Kinematics The forward kinematics problem for a serial-chain manipulator is to find the position and orientation of the end-effector relative to the base given the positions of all of the joints and the values of all of the geometric link parameters. Often, a frame fixed in the end-effector is referred to as the tool frame, and while fixed in the final link N, it in general has a constant offset in both position and orientation from frame N. Likewise, a station frame is often located in the base to establish the location of the task to be performed. This frame generally has a constant offset in its pose relative to frame 0, which is also fixed in the base. In practice, the forward kinematics problem is solved by calculating the transformation between a coordinate frame fixed in the end-effector and another coordinate frame fixed in the base, i.e., between the tool and station frames. This is straightforward for a serial chain since the transformation describing the position of the end-effector relative to the base is obtained by simply concatenating transformations between frames fixed in adjacent links of the chain. Inverse Kinematics The inverse kinematics problem for a serial-chain manipulator is to find the values of the joint positions given the position and orientation of the end-effector relative to the base and the values of all of the geometric link parameters. Once again, this is a simplified statement applying only to serial chains. A more general statement is: given the relative positions and orientations of two members of a mechanism, find the values of all of the joint positions. This amounts to finding all of the joint positions given the homogeneous transformation between the two members of interest. When solving the inverse problem, we often have to choose one solution from a number of valid solutions. There are also degenerate cases with an infinite number of solutions Some solutions of the inverse mapping may not be physically realizable. This is due to manipulators having physical joint limits that prevent the mechanism from achieving certain joint configurations that may be solutions to the inverse kinematics problem (e.g. a joint may not have a full 360 degree motion) To get a more detailed idea of solving inverse and forward kinematics problems for robotic system do checkout this 3 part video series from milfordrobotics Part-1 , Part-2 , Part-3","title":"Forward and Inverse Kinematics"},{"location":"mechanical/Forward%20and%20Inverse%20Kinematics/#forward-kinematics","text":"The forward kinematics problem for a serial-chain manipulator is to find the position and orientation of the end-effector relative to the base given the positions of all of the joints and the values of all of the geometric link parameters. Often, a frame fixed in the end-effector is referred to as the tool frame, and while fixed in the final link N, it in general has a constant offset in both position and orientation from frame N. Likewise, a station frame is often located in the base to establish the location of the task to be performed. This frame generally has a constant offset in its pose relative to frame 0, which is also fixed in the base. In practice, the forward kinematics problem is solved by calculating the transformation between a coordinate frame fixed in the end-effector and another coordinate frame fixed in the base, i.e., between the tool and station frames. This is straightforward for a serial chain since the transformation describing the position of the end-effector relative to the base is obtained by simply concatenating transformations between frames fixed in adjacent links of the chain.","title":"Forward Kinematics"},{"location":"mechanical/Forward%20and%20Inverse%20Kinematics/#inverse-kinematics","text":"The inverse kinematics problem for a serial-chain manipulator is to find the values of the joint positions given the position and orientation of the end-effector relative to the base and the values of all of the geometric link parameters. Once again, this is a simplified statement applying only to serial chains. A more general statement is: given the relative positions and orientations of two members of a mechanism, find the values of all of the joint positions. This amounts to finding all of the joint positions given the homogeneous transformation between the two members of interest. When solving the inverse problem, we often have to choose one solution from a number of valid solutions. There are also degenerate cases with an infinite number of solutions Some solutions of the inverse mapping may not be physically realizable. This is due to manipulators having physical joint limits that prevent the mechanism from achieving certain joint configurations that may be solutions to the inverse kinematics problem (e.g. a joint may not have a full 360 degree motion) To get a more detailed idea of solving inverse and forward kinematics problems for robotic system do checkout this 3 part video series from milfordrobotics Part-1 , Part-2 , Part-3","title":"Inverse Kinematics"},{"location":"mechanical/Gears/","text":"Gears What are Gears? Gears are defined as toothed element which are used for transmitting rotary motion from one shaft to another. Gears are most often used in transmissions to convert an electric motor\u2019s high speed and low torque to a shaft\u2019s requirements for low speed high torque. Gears essentially allow positive engagement between Teeth, so high forces can be transmitted while still undergoing essentially rolling contact. Gears do not depend on friction as belt drives and do best when friction is minimized. The motion and power transmitted by gears is kinematically equivalent to that transmitted by friction wheels or discs. (Transmission of Power) In order to avoid the slipping, a number of projections (called teeth) as shown in Fig. (b), are provided on the periphery of the wheel A, which will fit into the corresponding recesses on the periphery of the wheel B. A friction wheel with the teeth cut on it is known as toothed wheel or gear. The usual connection to show the toothed wheels is by their pitch circles Advantages and Disadvantages Advantages It transmits exact velocity ratio. It may be used to transmit large power. It has high efficiency. It has reliable service. It has compact layout. Disadvantages The manufacture of gears require special tools and equipment. The error in cutting teeth may cause vibrations and noise during operation. Types of Gears According to the position of axes of the shaft Parallel: Spur gear, Helical gear, Rack and Pinion Intersecting: Bevel Gear Non Intersecting and Non Parallel: Worm and Worm Gears According to the periphery velocity Low Velocity Medium Velocity High Velocity According to the type of gearing External Gearing Internal Gearing Rack and Pinion According to the position of teeth on surface Straight Inclined Curved Spur Gear Spur gears are a type of cylindrical gear, with shafts that are parallel and coplanar, and teeth that are straight and oriented parallel to the shafts. They\u2019re arguably the simplest and most common type of gear \u2013 easy to manufacture and suitable for a wide range of applications. The teeth of a spur gear have an involute profile and mesh one tooth at a time. The involute form means that spur gears only produce radial forces (no axial forces), but the method of tooth meshing causes high stress on the gear teeth and high noise production. Because of this, spur gears are typically used for lower speed applications, although they can be used at almost any speed. Spur gears are generally seen as best for applications that require speed reduction and torque multiplication, such as ball mills and crushing equipment. Examples of high-speed applications that use spur gears \u2013 despite their high noise levels \u2013 include consumer appliances such as washing machines and blenders. And while noise limits the use of spur gears in passenger automobiles, they are often used in aircraft engines, trains, and even bicycles. Helical Gear The teeth of a helical gear are set at an angle (relative to axis of the gear) and take the shape of a helix. This allows the teeth to mesh gradually, starting as point contact and developing into line contact as engagement progresses. One of the most noticeable benefits of helical gears over spur gears is less noise, especially at medium- to high-speeds. Also, with helical gears, multiple teeth are always in mesh, which means less load on each individual tooth. This results in a smoother transition of forces from one tooth to the next, so that vibrations, shock loads, and wear are reduced. One interesting thing about helical gears is that if the angles of the gear teeth are correct, they can be mounted on perpendicular shafts, adjusting the rotation angle by 90 degrees. Helical gears are often the default choice in applications that are suitable for spur gears but have non-parallel shafts. They are also used in applications that require high speeds or high loading. And regardless of the load or speed, they generally provide smoother, quieter operation than spur gears. Bevel Gear Bevel gears are gears where the axes of the two shafts intersect and the tooth-bearing faces of the gears themselves are conically shaped. Bevel gears are most often mounted on shafts that are 90 degrees apart, but can be designed to work at other angles as well. The pitch surface of bevel gears is a cone. There are several types of bevel gears based on the shape of their teeth. Straight They have conical pitch surface and teeth are straight and tapering towards apex. They are useful to verify the transmission of the motion that is generated between axes that intersect within one same plane, almost always at a 90-degree angle. Straight bevel gears have many uses in watches, dentist drills, hand drills and vending machines. Spiral They have curved teeth at an angle allowing tooth contact to be gradual and smooth and operate at very steep planes. Spiral bevel gears provide a high level of control over the way in which teeth mesh, and their design allows for certain mounting deflections without excessively increasing the load on either end of the teeth. They can be used at high speeds, and are usually employed in motorcycle and bicycle gears. Hypoid These are similar to spiral bevel, but the pitch surfaces are hyberbolic and not conical. The pinion can be offset above or below the gear center, thus allowing larger pinion diameter, longer life, and smoother mesh. In addition to being used in industrial machinery, they are commonly used in the automotive industry, where it is used in rear-wheel drive vehicles to connect the driveshaft with the wheels. Worm Gears Worm gears are constructed of a worm and a gear (sometimes referred to as a worm wheel), with non-parallel, non-intersecting shafts oriented 90 degrees to each other. The worm is analogous to a screw with a V-type thread, and the gear is analogous to a spur gear. The worm is typically the driving component, with the worm\u2019s thread advancing the teeth of the gear. The primary benefit of worm gears is their ability to provide high reduction ratios (like 20:1 and even up to 300:1 or greater) and correspondingly high torque multiplication. They can also be used as speed reducers in low- to medium-speed applications. And, because their reduction ratio is based on the number of gear teeth alone, they are more compact than other types of gears. Worm gears are used widely in material handling and transportation machinery, machine tools, automobiles etc. Herringbone Gear The herringbone gear consists of two sets of gear teeth on the same gear, one right hand and one left hand. Having both hands of gear teeth, causes the thrust of one set to cancel out the thrust of the other. It is used for transmitting power between parallel shafts. It was developed to overcome the disadvantage of the high-end thrust that is present with single-helical gears. Also another advantage of this gear type is quiet, smooth operation at higher speeds. They are mostly used on heavy machinery. Rack and Pinion A rack and pinion drive system consists of a rack (or a \u201clinear gear\u201d) and a pinion (or \u201ccircular gear\u201d), which operate to convert rotational motion into linear motion. A rack and pinion drive can use both straight and helical gears. These systems provide high-speed travel over extremely long lengths and are frequently used in large gantry systems for material handling, machining, welding and assembly, especially in the automotive, machine tool, and packaging industries. Planetary Gear A planetary gear set is made up of three types of gears; a sun gear, planet gears, and a ring gear. The sun gear is located at the center, and transmits torque to the planet gears which are typically mounted on a moveable carrier. The planet gears orbit around the sun gear and mesh with an outer ring gear. Planetary gear systems can vary in complexity from very simple to intricate compound systems, depending on the application. Planetary gear systems are able to produce a lot of torque because the load is shared among multiple planet gears. This arrangement also creates more contact surfaces and a larger contact area between the gears than a traditional parallel axis gear system. Because of this, in the load is more evenly distributed and therefore the gears are more resistant to damage. Planetary gears are often used when space and weight are an issue, but a large amount of speed reduction and torque are needed. This requirement applies to a variety of industries, including tractors and construction equipment where a large amount of torque is needed to drive the wheels. Other places you will find planetary gear sets include turbine engines, automatic transmissions, and even electric screwdrivers.","title":"Gears"},{"location":"mechanical/Gears/#gears","text":"","title":"Gears"},{"location":"mechanical/Gears/#what-are-gears","text":"Gears are defined as toothed element which are used for transmitting rotary motion from one shaft to another. Gears are most often used in transmissions to convert an electric motor\u2019s high speed and low torque to a shaft\u2019s requirements for low speed high torque. Gears essentially allow positive engagement between Teeth, so high forces can be transmitted while still undergoing essentially rolling contact. Gears do not depend on friction as belt drives and do best when friction is minimized. The motion and power transmitted by gears is kinematically equivalent to that transmitted by friction wheels or discs. (Transmission of Power) In order to avoid the slipping, a number of projections (called teeth) as shown in Fig. (b), are provided on the periphery of the wheel A, which will fit into the corresponding recesses on the periphery of the wheel B. A friction wheel with the teeth cut on it is known as toothed wheel or gear. The usual connection to show the toothed wheels is by their pitch circles","title":"What are Gears?"},{"location":"mechanical/Gears/#advantages-and-disadvantages","text":"","title":"Advantages and Disadvantages"},{"location":"mechanical/Gears/#advantages","text":"It transmits exact velocity ratio. It may be used to transmit large power. It has high efficiency. It has reliable service. It has compact layout.","title":"Advantages"},{"location":"mechanical/Gears/#disadvantages","text":"The manufacture of gears require special tools and equipment. The error in cutting teeth may cause vibrations and noise during operation.","title":"Disadvantages"},{"location":"mechanical/Gears/#types-of-gears","text":"According to the position of axes of the shaft Parallel: Spur gear, Helical gear, Rack and Pinion Intersecting: Bevel Gear Non Intersecting and Non Parallel: Worm and Worm Gears According to the periphery velocity Low Velocity Medium Velocity High Velocity According to the type of gearing External Gearing Internal Gearing Rack and Pinion According to the position of teeth on surface Straight Inclined Curved","title":"Types of Gears"},{"location":"mechanical/Gears/#spur-gear","text":"Spur gears are a type of cylindrical gear, with shafts that are parallel and coplanar, and teeth that are straight and oriented parallel to the shafts. They\u2019re arguably the simplest and most common type of gear \u2013 easy to manufacture and suitable for a wide range of applications. The teeth of a spur gear have an involute profile and mesh one tooth at a time. The involute form means that spur gears only produce radial forces (no axial forces), but the method of tooth meshing causes high stress on the gear teeth and high noise production. Because of this, spur gears are typically used for lower speed applications, although they can be used at almost any speed. Spur gears are generally seen as best for applications that require speed reduction and torque multiplication, such as ball mills and crushing equipment. Examples of high-speed applications that use spur gears \u2013 despite their high noise levels \u2013 include consumer appliances such as washing machines and blenders. And while noise limits the use of spur gears in passenger automobiles, they are often used in aircraft engines, trains, and even bicycles.","title":"Spur Gear"},{"location":"mechanical/Gears/#helical-gear","text":"The teeth of a helical gear are set at an angle (relative to axis of the gear) and take the shape of a helix. This allows the teeth to mesh gradually, starting as point contact and developing into line contact as engagement progresses. One of the most noticeable benefits of helical gears over spur gears is less noise, especially at medium- to high-speeds. Also, with helical gears, multiple teeth are always in mesh, which means less load on each individual tooth. This results in a smoother transition of forces from one tooth to the next, so that vibrations, shock loads, and wear are reduced. One interesting thing about helical gears is that if the angles of the gear teeth are correct, they can be mounted on perpendicular shafts, adjusting the rotation angle by 90 degrees. Helical gears are often the default choice in applications that are suitable for spur gears but have non-parallel shafts. They are also used in applications that require high speeds or high loading. And regardless of the load or speed, they generally provide smoother, quieter operation than spur gears.","title":"Helical Gear"},{"location":"mechanical/Gears/#bevel-gear","text":"Bevel gears are gears where the axes of the two shafts intersect and the tooth-bearing faces of the gears themselves are conically shaped. Bevel gears are most often mounted on shafts that are 90 degrees apart, but can be designed to work at other angles as well. The pitch surface of bevel gears is a cone. There are several types of bevel gears based on the shape of their teeth. Straight They have conical pitch surface and teeth are straight and tapering towards apex. They are useful to verify the transmission of the motion that is generated between axes that intersect within one same plane, almost always at a 90-degree angle. Straight bevel gears have many uses in watches, dentist drills, hand drills and vending machines. Spiral They have curved teeth at an angle allowing tooth contact to be gradual and smooth and operate at very steep planes. Spiral bevel gears provide a high level of control over the way in which teeth mesh, and their design allows for certain mounting deflections without excessively increasing the load on either end of the teeth. They can be used at high speeds, and are usually employed in motorcycle and bicycle gears. Hypoid These are similar to spiral bevel, but the pitch surfaces are hyberbolic and not conical. The pinion can be offset above or below the gear center, thus allowing larger pinion diameter, longer life, and smoother mesh. In addition to being used in industrial machinery, they are commonly used in the automotive industry, where it is used in rear-wheel drive vehicles to connect the driveshaft with the wheels.","title":"Bevel Gear"},{"location":"mechanical/Gears/#worm-gears","text":"Worm gears are constructed of a worm and a gear (sometimes referred to as a worm wheel), with non-parallel, non-intersecting shafts oriented 90 degrees to each other. The worm is analogous to a screw with a V-type thread, and the gear is analogous to a spur gear. The worm is typically the driving component, with the worm\u2019s thread advancing the teeth of the gear. The primary benefit of worm gears is their ability to provide high reduction ratios (like 20:1 and even up to 300:1 or greater) and correspondingly high torque multiplication. They can also be used as speed reducers in low- to medium-speed applications. And, because their reduction ratio is based on the number of gear teeth alone, they are more compact than other types of gears. Worm gears are used widely in material handling and transportation machinery, machine tools, automobiles etc.","title":"Worm Gears"},{"location":"mechanical/Gears/#herringbone-gear","text":"The herringbone gear consists of two sets of gear teeth on the same gear, one right hand and one left hand. Having both hands of gear teeth, causes the thrust of one set to cancel out the thrust of the other. It is used for transmitting power between parallel shafts. It was developed to overcome the disadvantage of the high-end thrust that is present with single-helical gears. Also another advantage of this gear type is quiet, smooth operation at higher speeds. They are mostly used on heavy machinery.","title":"Herringbone Gear"},{"location":"mechanical/Gears/#rack-and-pinion","text":"A rack and pinion drive system consists of a rack (or a \u201clinear gear\u201d) and a pinion (or \u201ccircular gear\u201d), which operate to convert rotational motion into linear motion. A rack and pinion drive can use both straight and helical gears. These systems provide high-speed travel over extremely long lengths and are frequently used in large gantry systems for material handling, machining, welding and assembly, especially in the automotive, machine tool, and packaging industries.","title":"Rack and Pinion"},{"location":"mechanical/Gears/#planetary-gear","text":"A planetary gear set is made up of three types of gears; a sun gear, planet gears, and a ring gear. The sun gear is located at the center, and transmits torque to the planet gears which are typically mounted on a moveable carrier. The planet gears orbit around the sun gear and mesh with an outer ring gear. Planetary gear systems can vary in complexity from very simple to intricate compound systems, depending on the application. Planetary gear systems are able to produce a lot of torque because the load is shared among multiple planet gears. This arrangement also creates more contact surfaces and a larger contact area between the gears than a traditional parallel axis gear system. Because of this, in the load is more evenly distributed and therefore the gears are more resistant to damage. Planetary gears are often used when space and weight are an issue, but a large amount of speed reduction and torque are needed. This requirement applies to a variety of industries, including tractors and construction equipment where a large amount of torque is needed to drive the wheels. Other places you will find planetary gear sets include turbine engines, automatic transmissions, and even electric screwdrivers.","title":"Planetary Gear"},{"location":"mechanical/Introduction%20to%20Dynamics/","text":"Introduction to Dynamics For many applications with fixed-based robots we need to find a multi-body dynamics formulated as: \\[ M(q)\\ddot{q} + b(q,\\dot{q}) + g(q) = \\tau \\: + J_{c}(q)^{T}F_{c} \\] consisting of the following components: \\(M(q)\\) \\(\\epsilon\\) \\(\\mathbf{R}\\) \\(^{n_{q}Xn_{q}}\\) Generalized Mass matrix(orthogonal) \\(q, \\dot{q}, \\ddot{q}\\) \\(\\epsilon\\) \\(\\mathbf{R}^{n_{q}}\\) Generalized position, velocity and acceleration vectors \\(b(q, \\dot{q})\\) \\(\\epsilon\\) \\(\\mathbf{R}^{n_{q}}\\) Coriolis and centrifugal terms. \\(g(q)\\) \\(\\epsilon\\) \\(\\mathbf{R}^{n_{q}}\\) Gravitational terms. \\(\\tau\\) \\(\\epsilon\\) \\(\\mathbf{R}^{n_{q}}\\) External generalized forces. \\(F_{c}\\) \\(\\epsilon\\) $ \\(\\mathbf{R}^{n_{q}}\\) External Cartesian forces (e.g. from contacts) \\(J_{c}(q)\\) \\(\\epsilon\\) \\(\\mathbf{R}^{n_{q}Xn_{q}}\\) Geometric Jacobian corresponding to the external forces. Different methods exist to compute the so-called Equations of Motion (EoM) of a given system, i.e., a closed-form mathematical model of the system dynamics. The two most common methods used in robotics are Newton-Euler method which essentially applies the principles of conservation of linear and angular momentum for all links of a robot and Lagrange Method which utilizes scalar energy-based functions over the the space of generalized coordinates which adhere to certain minimization principles, thus resulting in trajectories which automatically satisfy the kinematic constraints of the system. to understand better how problems related to dynamics in robotics are tackled do give a watch to this lecture on robot dynamics by IIT KGP Prof. Dilip Kumar Pratihar Newton-Euler Method Newton-Euler for Single Bodies a very well known formulation formed by Newton and Euler using law of angular and linear momentum is : \u200b \\(\\dot{\\mathsf{p}} _{S}\\) = \\(F_{ext,S}\\) \u200b \\(\\dot{\\mathbf{N}}_{S}\\) = \\(T_{ext}\\) where \\(F_{ext,S}\\) are the resultant external forces that act through the COG and \\(T_{ext}\\) are the resultant external torques. External forces which do not act through the COG need to be shifted to an equivalent force/moment pair of which the force acts through the COG. Newton-Euler for Multi-Body Systems When dealing with multi-body systems, a valid approach is to separate all bodies at the joints as depicted in and to consider every body as a single unit. Thereby, the constraint forces F \\(_{i}\\) at the joints must be introduced as external forces acting on each of the bodies when cut free. For all these bodies, we must then apply conservation of linear and angular momentum in all DoFs, subject to external forces (which now include the joint forces F \\(_{i}\\) , too). For a general 3D case and a fixed base, this results in a 6 \\(n_{j}\\) -dimensional systems of equations. Additionally, there are 5 \\(n_{j}\\) motion constraint due to the ideal joints. They ensure that the two connected bodies only move along the direction of the joint but don\u2019t move in all other directions that are blocked by the joint. Lagrange Method This method is centered around three fundamental concepts: The definition of generalized coordinates$ q$ and generalized velocities \\(\\dot{q}\\) , which may or may not encode the information regarding the constraints applicable to the system. . A scalar function called the Lagrangian function \\(\\mathcal{L}\\) . For mechanical systems, it is exactly the difference between the total kinetic energy \\(\\mathcal{T}\\) and the total potential energy \\(\\mathcal{U}\\) , of the system at each instant: \u200b \\(\\mathcal{L} = \\mathcal{T} - \\mathcal{U}\\) The so-called Euler-Lagrange equation, also known as the Euler-Lagrange of the second kind, which applies to the Lagrangian function \\(\\mathcal{L}\\) and to the total external generalized forces \\(\\tau\\) : \u200b \\(\\frac{d}{dt} (\\frac{\\partial{\\mathcal{L}}}{\\partial{\\dot{q}}} )\\) - \\((\\frac{\\partial{L}}{\\partial{\\dot{q}}})\\) = \\(\\tau\\) In the most general case, the Lagrangian is a function of the generalized coordinates and velocities q and q\u02d9 , and it may also have an explicit dependence on time t, hence we redefine the aforementioned scalar energy functions as \\(\\mathcal{T} = \\mathcal{T}(t, q, \\dot{q})\\) and \\(\\mathcal{U} = \\mathcal{U}(t,q)\\) , thus \\(\\mathcal{L} = \\mathcal{L}(t,q,\\dot{q})\\) . In the end, one of the most notable properties of this formulation is the capacity to eliminate all internal reaction forces of the system from the final EoM, in contrast to the Newton-Euler formulation where there they are explicitly accounted for. To get a more detailed insight on how to formulate Newton-Euler equation and Lagrange equation for different robot system check out this lecture by IIT Delhi prof S.K SAHA some of the other resources you can checkout to know more about kinematics and dynamics involved in robotics are: A Mathematical Introduction to Robotic Manipulation by Richard Murray Robot dynamics and control by Mark Spong Springer Handbook on Robotics by Oussama Khatib","title":"Introduction to Dynamics"},{"location":"mechanical/Introduction%20to%20Dynamics/#introduction-to-dynamics","text":"For many applications with fixed-based robots we need to find a multi-body dynamics formulated as: \\[ M(q)\\ddot{q} + b(q,\\dot{q}) + g(q) = \\tau \\: + J_{c}(q)^{T}F_{c} \\] consisting of the following components: \\(M(q)\\) \\(\\epsilon\\) \\(\\mathbf{R}\\) \\(^{n_{q}Xn_{q}}\\) Generalized Mass matrix(orthogonal) \\(q, \\dot{q}, \\ddot{q}\\) \\(\\epsilon\\) \\(\\mathbf{R}^{n_{q}}\\) Generalized position, velocity and acceleration vectors \\(b(q, \\dot{q})\\) \\(\\epsilon\\) \\(\\mathbf{R}^{n_{q}}\\) Coriolis and centrifugal terms. \\(g(q)\\) \\(\\epsilon\\) \\(\\mathbf{R}^{n_{q}}\\) Gravitational terms. \\(\\tau\\) \\(\\epsilon\\) \\(\\mathbf{R}^{n_{q}}\\) External generalized forces. \\(F_{c}\\) \\(\\epsilon\\) $ \\(\\mathbf{R}^{n_{q}}\\) External Cartesian forces (e.g. from contacts) \\(J_{c}(q)\\) \\(\\epsilon\\) \\(\\mathbf{R}^{n_{q}Xn_{q}}\\) Geometric Jacobian corresponding to the external forces. Different methods exist to compute the so-called Equations of Motion (EoM) of a given system, i.e., a closed-form mathematical model of the system dynamics. The two most common methods used in robotics are Newton-Euler method which essentially applies the principles of conservation of linear and angular momentum for all links of a robot and Lagrange Method which utilizes scalar energy-based functions over the the space of generalized coordinates which adhere to certain minimization principles, thus resulting in trajectories which automatically satisfy the kinematic constraints of the system. to understand better how problems related to dynamics in robotics are tackled do give a watch to this lecture on robot dynamics by IIT KGP Prof. Dilip Kumar Pratihar","title":"Introduction to Dynamics"},{"location":"mechanical/Introduction%20to%20Dynamics/#newton-euler-method","text":"","title":"Newton-Euler Method"},{"location":"mechanical/Introduction%20to%20Dynamics/#newton-euler-for-single-bodies","text":"a very well known formulation formed by Newton and Euler using law of angular and linear momentum is : \u200b \\(\\dot{\\mathsf{p}} _{S}\\) = \\(F_{ext,S}\\) \u200b \\(\\dot{\\mathbf{N}}_{S}\\) = \\(T_{ext}\\) where \\(F_{ext,S}\\) are the resultant external forces that act through the COG and \\(T_{ext}\\) are the resultant external torques. External forces which do not act through the COG need to be shifted to an equivalent force/moment pair of which the force acts through the COG.","title":"Newton-Euler for Single Bodies"},{"location":"mechanical/Introduction%20to%20Dynamics/#newton-euler-for-multi-body-systems","text":"When dealing with multi-body systems, a valid approach is to separate all bodies at the joints as depicted in and to consider every body as a single unit. Thereby, the constraint forces F \\(_{i}\\) at the joints must be introduced as external forces acting on each of the bodies when cut free. For all these bodies, we must then apply conservation of linear and angular momentum in all DoFs, subject to external forces (which now include the joint forces F \\(_{i}\\) , too). For a general 3D case and a fixed base, this results in a 6 \\(n_{j}\\) -dimensional systems of equations. Additionally, there are 5 \\(n_{j}\\) motion constraint due to the ideal joints. They ensure that the two connected bodies only move along the direction of the joint but don\u2019t move in all other directions that are blocked by the joint.","title":"Newton-Euler for Multi-Body Systems"},{"location":"mechanical/Introduction%20to%20Dynamics/#lagrange-method","text":"This method is centered around three fundamental concepts: The definition of generalized coordinates$ q$ and generalized velocities \\(\\dot{q}\\) , which may or may not encode the information regarding the constraints applicable to the system. . A scalar function called the Lagrangian function \\(\\mathcal{L}\\) . For mechanical systems, it is exactly the difference between the total kinetic energy \\(\\mathcal{T}\\) and the total potential energy \\(\\mathcal{U}\\) , of the system at each instant: \u200b \\(\\mathcal{L} = \\mathcal{T} - \\mathcal{U}\\) The so-called Euler-Lagrange equation, also known as the Euler-Lagrange of the second kind, which applies to the Lagrangian function \\(\\mathcal{L}\\) and to the total external generalized forces \\(\\tau\\) : \u200b \\(\\frac{d}{dt} (\\frac{\\partial{\\mathcal{L}}}{\\partial{\\dot{q}}} )\\) - \\((\\frac{\\partial{L}}{\\partial{\\dot{q}}})\\) = \\(\\tau\\) In the most general case, the Lagrangian is a function of the generalized coordinates and velocities q and q\u02d9 , and it may also have an explicit dependence on time t, hence we redefine the aforementioned scalar energy functions as \\(\\mathcal{T} = \\mathcal{T}(t, q, \\dot{q})\\) and \\(\\mathcal{U} = \\mathcal{U}(t,q)\\) , thus \\(\\mathcal{L} = \\mathcal{L}(t,q,\\dot{q})\\) . In the end, one of the most notable properties of this formulation is the capacity to eliminate all internal reaction forces of the system from the final EoM, in contrast to the Newton-Euler formulation where there they are explicitly accounted for. To get a more detailed insight on how to formulate Newton-Euler equation and Lagrange equation for different robot system check out this lecture by IIT Delhi prof S.K SAHA some of the other resources you can checkout to know more about kinematics and dynamics involved in robotics are: A Mathematical Introduction to Robotic Manipulation by Richard Murray Robot dynamics and control by Mark Spong Springer Handbook on Robotics by Oussama Khatib","title":"Lagrange Method"},{"location":"mechanical/Joint%20Kinematics/","text":"Joint Kinematics The links that compose the robotic mechanism are assumed to be perfectly rigid bodies having surfaces that are geometrically perfect in both position and shape. Accordingly, these rigid bodies are connected together at joints where their idealized surfaces are in ideal contact without any clearance between them. The respective geometries of these surfaces in contact determine the freedom of motion between the two links, or the joint kinematics. Revolute The most general form of a revolute joint, often abbreviated as R and sometimes referred to colloquially as a hinge or pin joint, is a lower pair composed of two congruent surfaces of revolution. The surfaces are the same except one of them is an external surface, convex in any plane normal to the axis of revolution, and one is an internal surface, concave in any plane normal to the axis. The position of one body relative to the other may be expressed as the angle between two lines normal to the joint axis, one fixed in each body. Thus, the joint has one degree of freedom (DOF). Prismatic The most general form of a prismatic joint, often abbreviated as P and sometimes referred colloquially as a sliding joint, is a lower pair formed from two congruent general cylindrical surfaces. A prismatic joint permits only sliding of one of the members joined relative to the other along the direction of extrusion. The position of one body relative to the other is determined by the distance between two points on a line parallel to the direction of sliding, with one point fixed in each body. Thus, this joint also has one degree of freedom. Helical The most general form of a helical joint, often abbreviated as H and sometimes referred to colloquially as a screw joint, is a lower pair formed from two helicoidal surfaces formed by extruding any curve along a helical path. The simple example is a bolt and nut wherein the basic generating curve is a pair of straight lines. Other types of joints include Planar, Spherical , Cylindrical , etc. 6-DOF Joint The motion of two bodies not jointed together can be modeled as a six-degree-of-freedom joint that introduces no constraints. This is particularly useful for mobile robots, such as aircraft, that make at most intermittent contact with the ground, and thus, a body in free motion relative to the fixed frame is termed a floating base. Such a free motion joint model enables the position and orientation of a floating base in space to be expressed with six joint variables. Geometric Representation The geometry of a robotic mechanism is conveniently defined by attaching coordinate frames to each link. While these frames could be located arbitrarily, it is advantageous both for consistency and computational efficiency to adhere to a convention for locating the frames on the links. A commonly used convention for selecting frames of reference in robotic applications is the Denavit-Hartenberg, or D-H convention. In this convention, each homogeneous transformation \\(A_{i}\\) is represented as a product of four basic transformations where the four quantities \\(\\theta_{i} , a_{i} , d_{i} , \\alpha_{i}\\) are parameters associated with link i and joint i. The four parameters \\(a_{i} ,\\alpha_{i} ,d_{i} , and \\: \\theta_{i}\\) in are generally given the names link length, link twist, link offset, and joint angle, respectively, three of the above four quantities are constant for a given link, while the fourth parameter, \\(\\theta i\\) for a revolute joint and \\(d_{i}\\) for a prismatic joint, is the joint variable. Check out this video to know more about how to use DH parameters for geometric representation or go here for know about DH notation in more detail.","title":"Joint Kinematics"},{"location":"mechanical/Joint%20Kinematics/#joint-kinematics","text":"The links that compose the robotic mechanism are assumed to be perfectly rigid bodies having surfaces that are geometrically perfect in both position and shape. Accordingly, these rigid bodies are connected together at joints where their idealized surfaces are in ideal contact without any clearance between them. The respective geometries of these surfaces in contact determine the freedom of motion between the two links, or the joint kinematics.","title":"Joint Kinematics"},{"location":"mechanical/Joint%20Kinematics/#revolute","text":"The most general form of a revolute joint, often abbreviated as R and sometimes referred to colloquially as a hinge or pin joint, is a lower pair composed of two congruent surfaces of revolution. The surfaces are the same except one of them is an external surface, convex in any plane normal to the axis of revolution, and one is an internal surface, concave in any plane normal to the axis. The position of one body relative to the other may be expressed as the angle between two lines normal to the joint axis, one fixed in each body. Thus, the joint has one degree of freedom (DOF).","title":"Revolute"},{"location":"mechanical/Joint%20Kinematics/#prismatic","text":"The most general form of a prismatic joint, often abbreviated as P and sometimes referred colloquially as a sliding joint, is a lower pair formed from two congruent general cylindrical surfaces. A prismatic joint permits only sliding of one of the members joined relative to the other along the direction of extrusion. The position of one body relative to the other is determined by the distance between two points on a line parallel to the direction of sliding, with one point fixed in each body. Thus, this joint also has one degree of freedom.","title":"Prismatic"},{"location":"mechanical/Joint%20Kinematics/#helical","text":"The most general form of a helical joint, often abbreviated as H and sometimes referred to colloquially as a screw joint, is a lower pair formed from two helicoidal surfaces formed by extruding any curve along a helical path. The simple example is a bolt and nut wherein the basic generating curve is a pair of straight lines. Other types of joints include Planar, Spherical , Cylindrical , etc.","title":"Helical"},{"location":"mechanical/Joint%20Kinematics/#6-dof-joint","text":"The motion of two bodies not jointed together can be modeled as a six-degree-of-freedom joint that introduces no constraints. This is particularly useful for mobile robots, such as aircraft, that make at most intermittent contact with the ground, and thus, a body in free motion relative to the fixed frame is termed a floating base. Such a free motion joint model enables the position and orientation of a floating base in space to be expressed with six joint variables.","title":"6-DOF Joint"},{"location":"mechanical/Joint%20Kinematics/#geometric-representation","text":"The geometry of a robotic mechanism is conveniently defined by attaching coordinate frames to each link. While these frames could be located arbitrarily, it is advantageous both for consistency and computational efficiency to adhere to a convention for locating the frames on the links. A commonly used convention for selecting frames of reference in robotic applications is the Denavit-Hartenberg, or D-H convention. In this convention, each homogeneous transformation \\(A_{i}\\) is represented as a product of four basic transformations where the four quantities \\(\\theta_{i} , a_{i} , d_{i} , \\alpha_{i}\\) are parameters associated with link i and joint i. The four parameters \\(a_{i} ,\\alpha_{i} ,d_{i} , and \\: \\theta_{i}\\) in are generally given the names link length, link twist, link offset, and joint angle, respectively, three of the above four quantities are constant for a given link, while the fourth parameter, \\(\\theta i\\) for a revolute joint and \\(d_{i}\\) for a prismatic joint, is the joint variable. Check out this video to know more about how to use DH parameters for geometric representation or go here for know about DH notation in more detail.","title":"Geometric Representation"},{"location":"mechanical/drive_mechanism/","text":"Drive Mechanism Wheeled mobile robots may be classified in two major categories, omnidirectional and nonholonomic. Omnidirectional wheeled mobile robots typically employ either omniwheels or mecanum wheels. An omniwheel is a typical wheel augmented with rollers on its outer circumference. These rollers spin freely about axes in the plane of the wheel and tangential to the wheel\u2019s outer circumference, and they allow sideways sliding while the wheel drives forward or backward without slip in that direction. Mecanum wheels are similar except that the spin axes of the circumferential rollers are not in the plane of the wheel. The sideways sliding allowed by omniwheels and mecanum wheels ensures that there are no velocity constraints on the robot\u2019s chassis. Nonholomic wheeled robots are subject to a single Pfaffian velocity constraint i.e. they cannot move sideways or parallel to the axis of the axel. Example for a nonholomic wheeled robot is a car and despite this velocity constraint, a car can reach any \\((\\phi,x,y)\\) configuration in an obstacle-free plane. In other words, the velocity constraint cannot be integrated to an equivalent configuration constraint, and therefore it is a nonholonomic constraint. If we want to prescribe the robot\u2019s movements in the environment, we need to know how the robot variables relate to the primary variables we can control: the angular positions and velocities of the wheel shafts. Therefore, a kinematical model of the robot has to be developed. Modeling of an Omnibase Robot Generally Omni wheeled robots use either a three wheeled platform or a four wheeled platform. Each design has its own advantages and disadvantages. In a three wheel design, wheels are at \\(120^{\\circ}\\) from each other and they offers greater traction as any reactive force is distributed through only three points and the robot is well balanced even on uneven terrain. The configuration of a robot is defined in the form \\(q = (x,y,\\theta)\\) , \\(d\\) is the distance between wheels and the center of the robot \\(v_i\\) and \\(\\omega_i\\) are the linear and angular velocity of the \\(i^{th}\\) wheel respectively. \\(v, v_n\\) are the two components of the linear velocity of the robot and \\(\\omega\\) is the angular velocity. The well known kinematic model of an omnidirectional robot located a \\((x,y,\\theta)\\) can be written as \\(v_x(t) = dx(t)/dt , v_y(t) = dy(t)/dt\\) and \\(\\omega(t) = d\\theta(t)/dt\\) . For a three wheeled robot \\[ \\begin{bmatrix} v_0(t)\\\\ v_1(t)\\\\ v_2(t) \\end{bmatrix} = \\begin{bmatrix} -sin\\pi/3 & cos\\pi/3 & d\\\\ 0 & -1 & d\\\\ sin\\pi/3 & cos\\pi/3 & d \\end{bmatrix} \\begin{bmatrix} v(t)\\\\ v_n(t)\\\\ \\omega(t) \\end{bmatrix} \\] Applying the inverse kinematics is possible to obtain the equations that determine the robot speeds related the wheels speed. Solving in order of \\(v\\) , \\(v_n\\) and \\(\\omega\\) , the following can be found \\[ v(t) = (\\sqrt{3}/3)(v_2(t) - v_0(t))\\] \\[v_n(t)=(1/3)(v_2(t) +v_0(t))\u2212(2/3)v_1(t)\\] \\[\\omega(t)=(1/(3d))(v_0(t) +v_1(t) +v_2(t)) \\] Modeling of a Nonholomic Robot A nonholomic robot is modelled in differnet ways which will then dictate the drive mechanism that can be applied on the robot. Differnet drive mechanism and modelling for a nonholomic robot are: Unicycle model Differential Drive Ackermann Steering Unicycle Model The simplest wheeled mobile robot is a single upright rolling wheel, or unicycle. The configuration of a robot with a wheel of radius \\(r\\) can be written in the form \\(q = (\\phi,x,y,\\theta)\\) , where \\((x,y)\\) is the contact point, \\(\\phi\\) is the heading direction, and \\(\\theta\\) is the rolling angle of the wheel. The kinematic equations can be written as \\[ \\dot{q} = \\begin{bmatrix} \\dot{\\phi}\\\\ \\dot{x}\\\\ \\dot{y}\\\\ \\dot{\\theta} \\end{bmatrix} = \\begin{bmatrix} 0 & 1\\\\ rcos\\phi & 0\\\\ rsin\\phi & 0\\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} u_1\\\\ u_2 \\end{bmatrix} = G(q)u = g_1(q)u_1 + g_2(q)u_2 \\] The control inputs are \\(u = (u_1,u_2)\\) , with \\(u_1\\) the wheel\u2019s forward-backward driving speed and \\(u_2\\) the heading direction turning speed. Three things to notice about these models are: (1) there is no drift - zero controls mean zero velocity; (2) the vector fields \\(g_i(q)\\) are generally functions of the configuration \\(q\\) ; and (3) \\(\\dot{q}\\) is linear in the controls. Differnetial Drive A differential drive is the most basic drive, which consists of two sets of wheels that can be driven independently. This is the most commonly used form of locomotion system used in robots as it\u2019s the simplest and easiest to implement. A differential drive robot consists of two independently driven wheels of radius \\(r\\) that rotate about the same axis, as well as one or more caster wheels, ball casters, or low-friction sliders that keep the robot horizontal. If both the wheels are driven in the same direction and speed, the robot will go in a straight line. If both wheels are turned with equal speed in opposite directions, as is clear from the diagram shown, the robot will rotate about the central point of the axis. Otherwise, depending on the speed of rotation and its direction, the center of rotation may fall anywhere on the line defined by the two contact points of the tires. Let the distance between the driven wheels be \\(2d\\) and choose the \\((x,y)\\) reference point halfway between the wheels. Writing the configuration as \\(q = (\\phi,x,y,\\theta_L,\\theta_R)\\) , where \\(\\theta_L\\) and \\(\\theta_R\\) are the rolling angles of the left and right wheels, respectively, the kinematic equations are \\[ \\dot{q} = \\begin{bmatrix} \\dot{\\phi}\\\\ \\dot{x}\\\\ \\dot{y}\\\\ \\dot{\\theta_L}\\\\ \\dot{\\theta_R} \\end{bmatrix} = \\begin{bmatrix} -r/2d & r/2d\\\\ \\frac{r}{2}cos\\phi & \\frac{r}{2}cos\\phi\\\\ \\frac{r}{2}sin\\phi & \\frac{r}{2}sin\\phi\\\\ 1 & 0\\\\ 0 & 1 \\end{bmatrix} \\begin{bmatrix} u_L\\\\ u_R \\end{bmatrix} \\] where \\(u_L\\) is the angular speed of the left wheel and \\(u_R\\) that of the right. A positive angular speed of each wheel corresponds to forward motion at that wheel. While we can vary the velocity of each wheel, for the robot to perform rolling motion, the robot must rotate about a point that lies along their common left and right wheel axis. The point that the robot rotates about is known as the ICC - Instantaneous Center of Curvature. By varying the linear velocity of the wheels \\(V_R\\) and \\(V_L\\) , we can vary the radius of curvature \\(R\\) that the robot follows. Because the rate of rotation \\(\\omega\\) about the ICC must be the same for both wheels, we can write the following equations \\[ \\omega(R + d) = V_R\\] \\[\\omega(R - d) = V_L \\] A differential drive robot cannot move in the direction along the axis - this is a singularity. Differential drive vehicles are very sensitive to slight changes in velocity in each of the wheels. Small errors in the relative velocities between the wheels can affect the robot trajectory. Ackermann Steering Drawbacks of the differential drive are its reliance on a caster wheel, which performs poorly at high speeds, and difficulties in driving straight lines as this requires both motors to drive at the exact same speed. These drawbacks are mitigated by car-like mechanisms, which are driven by a single motor and can steer their front wheels. This mechanism is known as Ackermann steering. To define the configuration of the car, we ignore the rolling angles of the four wheels and write \\(q = (\\phi,x,y,\\psi)\\) , where \\((x,y)\\) is the location of the midpoint between the rear wheels, \\(\\phi\\) is the car\u2019s heading direction, and \\(\\psi\\) is the steering angle of the car, defined at a virtual wheel at the midpoint between the front wheels. The controls are the forward speed \\(v\\) of the car at its reference point and the angular speed \\(\\omega\\) of the steering angle. The car\u2019s kinematics are \\[ \\dot{q} = \\begin{bmatrix} \\dot{\\phi}\\\\ \\dot{x}\\\\ \\dot{y}\\\\ \\dot{\\psi} \\end{bmatrix} = \\begin{bmatrix} (tan\\psi)/l & 0\\\\ cos\\phi & 0\\\\ sin\\phi & 0\\\\ 0 & 1 \\end{bmatrix} \\begin{bmatrix} v\\\\ \\omega \\end{bmatrix} \\] Disadvantages Of Ackermann Steering : The turning mechanism must be accurately controlled. A slight inaccuracy may cause large odometry errors The system is Non \u2013 Holonomic hence path planning is extremely difficult as well as inaccurate There are no direct directional actuators. Other type of Drive Mechanism There are many different ways in which a robot can be modelled and controlled, some other drive mechanism used in various systems are Skid Steering - The left and right wheels are driven independently. Steering is accomplished by actuating each side at a different rate or in a different direction, causing the wheels or tracks to slip, or skid, on the ground. The wheels typically have no separate steering mechanism and hold a fixed straight alignment on the body of the machine. By turning the left and right wheel pairs at different speeds, the machine turns by skidding, or dragging its fixed-orientation wheels across the ground. Synchronous Drive - This system uses synchronous rotation of its wheels to achieve motion & turns. It is made up of a system of motors. One set of which drive the wheels and the other set turns the wheels in a synchronous fashion The two sets can be directly mechanically coupled as they always move in the same direction with same speed. Articulated Drive - Similar to Ackerman Steering concept, Articulated method drives a robot by deforming the entire chassis or frame to turn instead of just the wheels. This is generally used for industrial robots where a four wheeled robot is split into two, the front part and the rear part which is connected by a vertical hinge. A motor changes the angle of front part of chassis which turns the robot in a required direction and other motor drives it. References A 4-wheel omni drive robot - Omnibase developed by ERC, applying the concepts of omnidrive can be found here . For more details on these drive mechanisms refer Chapter 13 of the Modern Robotics - Mechanics, Planning, And Control by Kevin M. Lynch and Frank C. Park , a video playlist of the same can be found here . A video on Differential Drive mechanism from Control of Mobile Robots course by Dr. Magnus Egerstedt can be found here . More information on Designing of Ackermann Steering can be read from this paper .","title":"Drive Mechanism"},{"location":"mechanical/drive_mechanism/#drive-mechanism","text":"Wheeled mobile robots may be classified in two major categories, omnidirectional and nonholonomic. Omnidirectional wheeled mobile robots typically employ either omniwheels or mecanum wheels. An omniwheel is a typical wheel augmented with rollers on its outer circumference. These rollers spin freely about axes in the plane of the wheel and tangential to the wheel\u2019s outer circumference, and they allow sideways sliding while the wheel drives forward or backward without slip in that direction. Mecanum wheels are similar except that the spin axes of the circumferential rollers are not in the plane of the wheel. The sideways sliding allowed by omniwheels and mecanum wheels ensures that there are no velocity constraints on the robot\u2019s chassis. Nonholomic wheeled robots are subject to a single Pfaffian velocity constraint i.e. they cannot move sideways or parallel to the axis of the axel. Example for a nonholomic wheeled robot is a car and despite this velocity constraint, a car can reach any \\((\\phi,x,y)\\) configuration in an obstacle-free plane. In other words, the velocity constraint cannot be integrated to an equivalent configuration constraint, and therefore it is a nonholonomic constraint. If we want to prescribe the robot\u2019s movements in the environment, we need to know how the robot variables relate to the primary variables we can control: the angular positions and velocities of the wheel shafts. Therefore, a kinematical model of the robot has to be developed.","title":"Drive Mechanism"},{"location":"mechanical/drive_mechanism/#modeling-of-an-omnibase-robot","text":"Generally Omni wheeled robots use either a three wheeled platform or a four wheeled platform. Each design has its own advantages and disadvantages. In a three wheel design, wheels are at \\(120^{\\circ}\\) from each other and they offers greater traction as any reactive force is distributed through only three points and the robot is well balanced even on uneven terrain. The configuration of a robot is defined in the form \\(q = (x,y,\\theta)\\) , \\(d\\) is the distance between wheels and the center of the robot \\(v_i\\) and \\(\\omega_i\\) are the linear and angular velocity of the \\(i^{th}\\) wheel respectively. \\(v, v_n\\) are the two components of the linear velocity of the robot and \\(\\omega\\) is the angular velocity. The well known kinematic model of an omnidirectional robot located a \\((x,y,\\theta)\\) can be written as \\(v_x(t) = dx(t)/dt , v_y(t) = dy(t)/dt\\) and \\(\\omega(t) = d\\theta(t)/dt\\) . For a three wheeled robot \\[ \\begin{bmatrix} v_0(t)\\\\ v_1(t)\\\\ v_2(t) \\end{bmatrix} = \\begin{bmatrix} -sin\\pi/3 & cos\\pi/3 & d\\\\ 0 & -1 & d\\\\ sin\\pi/3 & cos\\pi/3 & d \\end{bmatrix} \\begin{bmatrix} v(t)\\\\ v_n(t)\\\\ \\omega(t) \\end{bmatrix} \\] Applying the inverse kinematics is possible to obtain the equations that determine the robot speeds related the wheels speed. Solving in order of \\(v\\) , \\(v_n\\) and \\(\\omega\\) , the following can be found \\[ v(t) = (\\sqrt{3}/3)(v_2(t) - v_0(t))\\] \\[v_n(t)=(1/3)(v_2(t) +v_0(t))\u2212(2/3)v_1(t)\\] \\[\\omega(t)=(1/(3d))(v_0(t) +v_1(t) +v_2(t)) \\]","title":"Modeling of an Omnibase Robot"},{"location":"mechanical/drive_mechanism/#modeling-of-a-nonholomic-robot","text":"A nonholomic robot is modelled in differnet ways which will then dictate the drive mechanism that can be applied on the robot. Differnet drive mechanism and modelling for a nonholomic robot are: Unicycle model Differential Drive Ackermann Steering","title":"Modeling of a Nonholomic Robot"},{"location":"mechanical/drive_mechanism/#unicycle-model","text":"The simplest wheeled mobile robot is a single upright rolling wheel, or unicycle. The configuration of a robot with a wheel of radius \\(r\\) can be written in the form \\(q = (\\phi,x,y,\\theta)\\) , where \\((x,y)\\) is the contact point, \\(\\phi\\) is the heading direction, and \\(\\theta\\) is the rolling angle of the wheel. The kinematic equations can be written as \\[ \\dot{q} = \\begin{bmatrix} \\dot{\\phi}\\\\ \\dot{x}\\\\ \\dot{y}\\\\ \\dot{\\theta} \\end{bmatrix} = \\begin{bmatrix} 0 & 1\\\\ rcos\\phi & 0\\\\ rsin\\phi & 0\\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} u_1\\\\ u_2 \\end{bmatrix} = G(q)u = g_1(q)u_1 + g_2(q)u_2 \\] The control inputs are \\(u = (u_1,u_2)\\) , with \\(u_1\\) the wheel\u2019s forward-backward driving speed and \\(u_2\\) the heading direction turning speed. Three things to notice about these models are: (1) there is no drift - zero controls mean zero velocity; (2) the vector fields \\(g_i(q)\\) are generally functions of the configuration \\(q\\) ; and (3) \\(\\dot{q}\\) is linear in the controls.","title":"Unicycle Model"},{"location":"mechanical/drive_mechanism/#differnetial-drive","text":"A differential drive is the most basic drive, which consists of two sets of wheels that can be driven independently. This is the most commonly used form of locomotion system used in robots as it\u2019s the simplest and easiest to implement. A differential drive robot consists of two independently driven wheels of radius \\(r\\) that rotate about the same axis, as well as one or more caster wheels, ball casters, or low-friction sliders that keep the robot horizontal. If both the wheels are driven in the same direction and speed, the robot will go in a straight line. If both wheels are turned with equal speed in opposite directions, as is clear from the diagram shown, the robot will rotate about the central point of the axis. Otherwise, depending on the speed of rotation and its direction, the center of rotation may fall anywhere on the line defined by the two contact points of the tires. Let the distance between the driven wheels be \\(2d\\) and choose the \\((x,y)\\) reference point halfway between the wheels. Writing the configuration as \\(q = (\\phi,x,y,\\theta_L,\\theta_R)\\) , where \\(\\theta_L\\) and \\(\\theta_R\\) are the rolling angles of the left and right wheels, respectively, the kinematic equations are \\[ \\dot{q} = \\begin{bmatrix} \\dot{\\phi}\\\\ \\dot{x}\\\\ \\dot{y}\\\\ \\dot{\\theta_L}\\\\ \\dot{\\theta_R} \\end{bmatrix} = \\begin{bmatrix} -r/2d & r/2d\\\\ \\frac{r}{2}cos\\phi & \\frac{r}{2}cos\\phi\\\\ \\frac{r}{2}sin\\phi & \\frac{r}{2}sin\\phi\\\\ 1 & 0\\\\ 0 & 1 \\end{bmatrix} \\begin{bmatrix} u_L\\\\ u_R \\end{bmatrix} \\] where \\(u_L\\) is the angular speed of the left wheel and \\(u_R\\) that of the right. A positive angular speed of each wheel corresponds to forward motion at that wheel. While we can vary the velocity of each wheel, for the robot to perform rolling motion, the robot must rotate about a point that lies along their common left and right wheel axis. The point that the robot rotates about is known as the ICC - Instantaneous Center of Curvature. By varying the linear velocity of the wheels \\(V_R\\) and \\(V_L\\) , we can vary the radius of curvature \\(R\\) that the robot follows. Because the rate of rotation \\(\\omega\\) about the ICC must be the same for both wheels, we can write the following equations \\[ \\omega(R + d) = V_R\\] \\[\\omega(R - d) = V_L \\] A differential drive robot cannot move in the direction along the axis - this is a singularity. Differential drive vehicles are very sensitive to slight changes in velocity in each of the wheels. Small errors in the relative velocities between the wheels can affect the robot trajectory.","title":"Differnetial Drive"},{"location":"mechanical/drive_mechanism/#ackermann-steering","text":"Drawbacks of the differential drive are its reliance on a caster wheel, which performs poorly at high speeds, and difficulties in driving straight lines as this requires both motors to drive at the exact same speed. These drawbacks are mitigated by car-like mechanisms, which are driven by a single motor and can steer their front wheels. This mechanism is known as Ackermann steering. To define the configuration of the car, we ignore the rolling angles of the four wheels and write \\(q = (\\phi,x,y,\\psi)\\) , where \\((x,y)\\) is the location of the midpoint between the rear wheels, \\(\\phi\\) is the car\u2019s heading direction, and \\(\\psi\\) is the steering angle of the car, defined at a virtual wheel at the midpoint between the front wheels. The controls are the forward speed \\(v\\) of the car at its reference point and the angular speed \\(\\omega\\) of the steering angle. The car\u2019s kinematics are \\[ \\dot{q} = \\begin{bmatrix} \\dot{\\phi}\\\\ \\dot{x}\\\\ \\dot{y}\\\\ \\dot{\\psi} \\end{bmatrix} = \\begin{bmatrix} (tan\\psi)/l & 0\\\\ cos\\phi & 0\\\\ sin\\phi & 0\\\\ 0 & 1 \\end{bmatrix} \\begin{bmatrix} v\\\\ \\omega \\end{bmatrix} \\] Disadvantages Of Ackermann Steering : The turning mechanism must be accurately controlled. A slight inaccuracy may cause large odometry errors The system is Non \u2013 Holonomic hence path planning is extremely difficult as well as inaccurate There are no direct directional actuators.","title":"Ackermann Steering"},{"location":"mechanical/drive_mechanism/#other-type-of-drive-mechanism","text":"There are many different ways in which a robot can be modelled and controlled, some other drive mechanism used in various systems are Skid Steering - The left and right wheels are driven independently. Steering is accomplished by actuating each side at a different rate or in a different direction, causing the wheels or tracks to slip, or skid, on the ground. The wheels typically have no separate steering mechanism and hold a fixed straight alignment on the body of the machine. By turning the left and right wheel pairs at different speeds, the machine turns by skidding, or dragging its fixed-orientation wheels across the ground. Synchronous Drive - This system uses synchronous rotation of its wheels to achieve motion & turns. It is made up of a system of motors. One set of which drive the wheels and the other set turns the wheels in a synchronous fashion The two sets can be directly mechanically coupled as they always move in the same direction with same speed. Articulated Drive - Similar to Ackerman Steering concept, Articulated method drives a robot by deforming the entire chassis or frame to turn instead of just the wheels. This is generally used for industrial robots where a four wheeled robot is split into two, the front part and the rear part which is connected by a vertical hinge. A motor changes the angle of front part of chassis which turns the robot in a required direction and other motor drives it.","title":"Other type of Drive Mechanism"},{"location":"mechanical/drive_mechanism/#references","text":"A 4-wheel omni drive robot - Omnibase developed by ERC, applying the concepts of omnidrive can be found here . For more details on these drive mechanisms refer Chapter 13 of the Modern Robotics - Mechanics, Planning, And Control by Kevin M. Lynch and Frank C. Park , a video playlist of the same can be found here . A video on Differential Drive mechanism from Control of Mobile Robots course by Dr. Magnus Egerstedt can be found here . More information on Designing of Ackermann Steering can be read from this paper .","title":"References"},{"location":"mechanical/intro/","text":"Introduction","title":"Introduction"},{"location":"mechanical/intro/#introduction","text":"","title":"Introduction"},{"location":"mechanical/position%20and%20orientation/","text":"POSITION AND ORIENATION REPRESENTATION Position and translation The minimum number of coordinates required to locate a body in Euclidean space is six. A coordinate frame i consists of an origin, denoted \\(O_{i}\\) and a triad of mutually orthogonal basis vectors, denoted \\((\\hat x_{i} \\hat y_{i } \\hat z_{i})\\) , that are all fixed within a particular body. The pose of a body will always be expressed relative to some other body, so it can be expressed as the pose of one coordinate frame relative to another. Similarly, rigid-body displacements can be expressed as displacements between two coordinate frames, one of which may be referred to as moving, while the other may be referred to as fixed. The position of the origin of coordinate frame i relative to coordinate frame j can be denoted by the 3 X 1 vector \\[ ^{j} \\textbf {p} _{i} = \\begin{pmatrix} ^{j} p^{x} _{i} \\\\ ^{j} p^{y} _{i} \\\\ ^{j} p^{z} _{i} \\end{pmatrix}\\] The components of this vector are the Cartesian coordinates of \\(O_{i}\\) in the j frame, which are the projections of the vector \\(^{j} \\textbf {p} _{i}\\) onto the corresponding axes. Orientation and Rotation A rotation is a displacement in which at least one point in the rigid body remains in its initial position and not all lines in the body remain parallel to their initial orientations. The orientation of coordinate frame i relative to coordinate frame j can be denoted by expressing the basis vectors . \\(( \\hat x_{i} \\hat y_{i} \\hat z_{i})\\) in terms of the basis vectors , \\(( \\hat x_{j} \\hat y_{j} \\hat z_{j})\\) .This yields, \\(( ^{j}\\hat x_{i} ^{j}\\hat y_{i} ^{j}\\hat z_{i})\\) which when written together as a 3X3 matrix is known as the rotation matrix. The components of \\(^{j}R_{i}\\) are the dot products of the basis vectors of the two coordinate frames. \\(^{j}R_{i}\\) = \\(\\begin{pmatrix} \\hat x _{i}.\\hat x _{j} & \\hat y _{i}.\\hat x _{j} & \\hat z _{i}.\\hat x _{j} \\\\ \\hat x _{i}.\\hat y _{j} & \\hat y _{i}.\\hat y _{j} & \\hat z _{i}.\\hat y _{j} \\\\ \\hat x _{i}.\\hat z _{j} & \\hat y _{i}.\\hat z _{j} & \\hat z _{i}.\\hat z _{j} \\end{pmatrix}\\) Because the basis vectors are unit vectors and the dot product of any two unit vectors is the cosine of the angle between them, the components are commonly referred to as direction cosines. An elementary rotation of frame i about the \\(z_{j}\\) axis through an angle \\(\\theta\\) is \\(R_{z}(\\theta) = \\begin{pmatrix} \\cos(\\theta) & -\\sin(\\theta) & 0\\\\ \\sin(\\theta) & \\cos(\\theta) & 0\\\\ 0 & 0 & 1\\end{pmatrix}\\) while the same rotation about \\(\\hat y_{j}\\) axis is \\(R_{Y}(\\theta) = \\begin{pmatrix} \\cos(\\theta) & 0 & \\sin(\\theta)\\\\ 0 & 1 & 0\\\\ -\\sin(\\theta) & 0 & \\cos(\\theta)\\end{pmatrix}\\) and about the axis \\(\\hat x_{j}\\) is \\(R_{X}(\\theta) = \\begin{pmatrix} 1 & 0 & 0\\\\ 0 & \\cos(\\theta) & -\\sin(\\theta)\\\\ 0 & \\sin(\\theta) & \\cos(\\theta)\\end{pmatrix}\\) Rotation matrices are combined through simple matrix multiplication such that the orientation of frame i relative to frame k can be expressed as \\(^{k}R_{i} = ^{k}R_{j} ^{j}R_{i}\\) Euler Angles For a minimal representation, the orientation of coordinate frame i relative to coordinate frame j can be denoted as a vector of three angles \\((\\alpha , \\beta , \\gamma)^{T}\\) . These angles are known as Euler angles when each represents a rotation about an axis of a moving coordinate frame. In this way, the location of the axis of each successive rotation depends upon the preceding rotation(s), so the order of the rotations must accompany the three angles to define the orientation. There are many other representations for orientation such as Fixed-Angles , Quaternions and Angle-Axis . Homogeneous Transformations With homogeneous transformations, position vectors and rotation matrices are combined together in a compact notation. Any vector \\(^{i}r\\) expressed relative to the i coordinate frame can be expressed relative to the j coordinate frame if the position and orientation of the i frame are known relative to the j frame. \\(^{j}r = ^{j}R_{i} ^{i}r + ^{j}p_{i}\\) where \\(^{j}p_{i}\\) is the position of the origin of coordinate frame i relative to coordinate frame j and \\(^{j}R_{i}\\) is the orientation of frame i relative to frame j . The above equation can be written as \\(\\begin{pmatrix} ^{j}r \\\\ 1 \\end{pmatrix}\\) = \\(\\begin{pmatrix} ^{j}R_{i} & ^{j}p_{i}\\\\ 0^{T} & 1 \\end{pmatrix}\\begin{pmatrix} ^{i}r \\\\ 1 \\end{pmatrix}\\) where \\(^{j}T_{i} = \\begin{pmatrix} ^{j}R_{i} & ^{j}p_{i}\\\\ 0^{T} & 1 \\end{pmatrix}\\) is the 4X4 homogeneous transformation matrix . Just like Rotation matrices, homogeneous transformation matrices can also be transformed using matrix cross-multiplication. \\(^{k}T_{i} = ^{k}T_{j} ^{j}T_{i}\\)","title":"Position and Orientation"},{"location":"mechanical/position%20and%20orientation/#position-and-orienation-representation","text":"","title":"POSITION AND ORIENATION REPRESENTATION"},{"location":"mechanical/position%20and%20orientation/#position-and-translation","text":"The minimum number of coordinates required to locate a body in Euclidean space is six. A coordinate frame i consists of an origin, denoted \\(O_{i}\\) and a triad of mutually orthogonal basis vectors, denoted \\((\\hat x_{i} \\hat y_{i } \\hat z_{i})\\) , that are all fixed within a particular body. The pose of a body will always be expressed relative to some other body, so it can be expressed as the pose of one coordinate frame relative to another. Similarly, rigid-body displacements can be expressed as displacements between two coordinate frames, one of which may be referred to as moving, while the other may be referred to as fixed. The position of the origin of coordinate frame i relative to coordinate frame j can be denoted by the 3 X 1 vector \\[ ^{j} \\textbf {p} _{i} = \\begin{pmatrix} ^{j} p^{x} _{i} \\\\ ^{j} p^{y} _{i} \\\\ ^{j} p^{z} _{i} \\end{pmatrix}\\] The components of this vector are the Cartesian coordinates of \\(O_{i}\\) in the j frame, which are the projections of the vector \\(^{j} \\textbf {p} _{i}\\) onto the corresponding axes.","title":"Position and translation"},{"location":"mechanical/position%20and%20orientation/#orientation-and-rotation","text":"A rotation is a displacement in which at least one point in the rigid body remains in its initial position and not all lines in the body remain parallel to their initial orientations. The orientation of coordinate frame i relative to coordinate frame j can be denoted by expressing the basis vectors . \\(( \\hat x_{i} \\hat y_{i} \\hat z_{i})\\) in terms of the basis vectors , \\(( \\hat x_{j} \\hat y_{j} \\hat z_{j})\\) .This yields, \\(( ^{j}\\hat x_{i} ^{j}\\hat y_{i} ^{j}\\hat z_{i})\\) which when written together as a 3X3 matrix is known as the rotation matrix. The components of \\(^{j}R_{i}\\) are the dot products of the basis vectors of the two coordinate frames. \\(^{j}R_{i}\\) = \\(\\begin{pmatrix} \\hat x _{i}.\\hat x _{j} & \\hat y _{i}.\\hat x _{j} & \\hat z _{i}.\\hat x _{j} \\\\ \\hat x _{i}.\\hat y _{j} & \\hat y _{i}.\\hat y _{j} & \\hat z _{i}.\\hat y _{j} \\\\ \\hat x _{i}.\\hat z _{j} & \\hat y _{i}.\\hat z _{j} & \\hat z _{i}.\\hat z _{j} \\end{pmatrix}\\) Because the basis vectors are unit vectors and the dot product of any two unit vectors is the cosine of the angle between them, the components are commonly referred to as direction cosines. An elementary rotation of frame i about the \\(z_{j}\\) axis through an angle \\(\\theta\\) is \\(R_{z}(\\theta) = \\begin{pmatrix} \\cos(\\theta) & -\\sin(\\theta) & 0\\\\ \\sin(\\theta) & \\cos(\\theta) & 0\\\\ 0 & 0 & 1\\end{pmatrix}\\) while the same rotation about \\(\\hat y_{j}\\) axis is \\(R_{Y}(\\theta) = \\begin{pmatrix} \\cos(\\theta) & 0 & \\sin(\\theta)\\\\ 0 & 1 & 0\\\\ -\\sin(\\theta) & 0 & \\cos(\\theta)\\end{pmatrix}\\) and about the axis \\(\\hat x_{j}\\) is \\(R_{X}(\\theta) = \\begin{pmatrix} 1 & 0 & 0\\\\ 0 & \\cos(\\theta) & -\\sin(\\theta)\\\\ 0 & \\sin(\\theta) & \\cos(\\theta)\\end{pmatrix}\\) Rotation matrices are combined through simple matrix multiplication such that the orientation of frame i relative to frame k can be expressed as \\(^{k}R_{i} = ^{k}R_{j} ^{j}R_{i}\\)","title":"Orientation and Rotation"},{"location":"mechanical/position%20and%20orientation/#euler-angles","text":"For a minimal representation, the orientation of coordinate frame i relative to coordinate frame j can be denoted as a vector of three angles \\((\\alpha , \\beta , \\gamma)^{T}\\) . These angles are known as Euler angles when each represents a rotation about an axis of a moving coordinate frame. In this way, the location of the axis of each successive rotation depends upon the preceding rotation(s), so the order of the rotations must accompany the three angles to define the orientation. There are many other representations for orientation such as Fixed-Angles , Quaternions and Angle-Axis .","title":"Euler Angles"},{"location":"mechanical/position%20and%20orientation/#homogeneous-transformations","text":"With homogeneous transformations, position vectors and rotation matrices are combined together in a compact notation. Any vector \\(^{i}r\\) expressed relative to the i coordinate frame can be expressed relative to the j coordinate frame if the position and orientation of the i frame are known relative to the j frame. \\(^{j}r = ^{j}R_{i} ^{i}r + ^{j}p_{i}\\) where \\(^{j}p_{i}\\) is the position of the origin of coordinate frame i relative to coordinate frame j and \\(^{j}R_{i}\\) is the orientation of frame i relative to frame j . The above equation can be written as \\(\\begin{pmatrix} ^{j}r \\\\ 1 \\end{pmatrix}\\) = \\(\\begin{pmatrix} ^{j}R_{i} & ^{j}p_{i}\\\\ 0^{T} & 1 \\end{pmatrix}\\begin{pmatrix} ^{i}r \\\\ 1 \\end{pmatrix}\\) where \\(^{j}T_{i} = \\begin{pmatrix} ^{j}R_{i} & ^{j}p_{i}\\\\ 0^{T} & 1 \\end{pmatrix}\\) is the 4X4 homogeneous transformation matrix . Just like Rotation matrices, homogeneous transformation matrices can also be transformed using matrix cross-multiplication. \\(^{k}T_{i} = ^{k}T_{j} ^{j}T_{i}\\)","title":"Homogeneous Transformations"},{"location":"simulation/intro/","text":"Introduction Simulation is an essential part of Robotics Automation. They provide a versatile platform to quickly test your code for bugs and performance and try out new ideas. While robots are becoming more accessible all the time, it is still not at the stage where you can test your code directly on them. In fact, running code in simulations will always be more convenient. For a more thorough introduction on simulators and the robots you can find in them, go through Chapter 6 of Morgan Quigley.","title":"Introduction"},{"location":"simulation/intro/#introduction","text":"Simulation is an essential part of Robotics Automation. They provide a versatile platform to quickly test your code for bugs and performance and try out new ideas. While robots are becoming more accessible all the time, it is still not at the stage where you can test your code directly on them. In fact, running code in simulations will always be more convenient. For a more thorough introduction on simulators and the robots you can find in them, go through Chapter 6 of Morgan Quigley.","title":"Introduction"},{"location":"simulation/gazebo/Robot%20Description/","text":"Robot Description 1.) http://gazebosim.org/tutorials?tut=components&cat=get_started 2.) Explaining URDF, SDF, .world and the differences between them 3.) Links on how to write urdf, sdf and .world files 4.) BB8 video tutorial","title":"Robot Description"},{"location":"simulation/gazebo/Robot%20Description/#robot-description","text":"1.) http://gazebosim.org/tutorials?tut=components&cat=get_started 2.) Explaining URDF, SDF, .world and the differences between them 3.) Links on how to write urdf, sdf and .world files 4.) BB8 video tutorial","title":"Robot Description"},{"location":"simulation/gazebo/basics/","text":"Gazebo Gazebo is the most popular physics simulator for robotics development. It can simulate robots in a 3D environment and can be fully integrated into ROS integrated with Gazebo using the gazebo_ros ROS package. You can interface your robots in the simulation using ROS and control them using ROS messages and services. 2.1 Installation Gazebo and gazebo_ros package are both automatically installed when you install ROS. To make sure you have all the ROS packages necessary for running Gazebo simulations are installed sudo apt-get install ros-melodic-gazebo-* Gazebo can also be installed independently of ROS by using the command curl -sSL http://get.gazebosim.org | sh in the terminal for Ubuntu. Alternative methods of installing gazebo and installation guides for installling gazebo on other operating systems can be found here . 2.2 Getting Started You can launch the Gazebo GUI simulator window by just running the command gazebo in the terminal. To understand how to spawn robot models in gazebo it is recommended to first get familiar with .urdf , .sdf and .world files. You can refer to the Robot Description section to read about these. A file can be opened simply by running the follwing command in the command line: gazebo <path/to/file> 2.3 Client Server Separation Running the gazebo command starts two programmes, namely the gzserver and the gzclient . The gzserver is responsible for doing most of the \u2018processing\u2019 part, i.e., doing all the calculations for the simulation, sensor data generation, basically all the backend processing. The gzclient is responsible for generating the user interface. It provides a nice visualization of simulation, and convenient controls over various simulation properties. gzserver is capable of running independently of gzclient and vice-versa. For eg; in many cases gzserver is run on a cloud computer in case enough processing power is not available locally. Try running the command gzserver in one terminal and the command gzclient in other terminal. You will notice that the gazebo window pops up only when you run the gzclient command. The term run headless is used to refer to cases when only the gzserver is being used. 2.4 Environment Variables in Gazebo Environment Variables are variables whose values are valid throughout the system and are used by different applications and the OS for several purposes. These environment variables can contain different types of things ranging from parameter values to paths to certain files depending on what they are used for. Gazebo uses various such environment variables too. These variables and their uses are described below: GAZEBO_MODEL_PATH : This environment variable contains colon-separated paths to different directories where gazebo will search for models. Models refers to the sdf file describing the robot. For more information on this refer to the Robot Description section of the handbook. GAZEBO_RESOURCE_PATH: This environment variable contains colon-separated set of directories where Gazebo will search for other resources such as world and media files. For eg. if you run the command gazebo worlds/pioneer2dx.world . You will see gazebo window pop up with an empty environment. In fact you can execute this command in any directory. You might ask how does gazebo know where the worlds directory is stored?. The answer is that the path to the world directory, that is /usr/share/gazebo-7/worlds is stored in the environment variable GAZEBO_RESOURCE_PATH . GAZEBO_MASTER__URI: URI of the Gazebo master . This specifies the IP and port where the server(gzserver) will be started and tells the clients(gzclients) where to connect to. GAZEBO_PLUGIN_PATH: colon-separated set of directories where Gazebo will search for the plugin shared libraries at runtime. Plugins are basically..... You can refer to this section to read more about gazebo plugins. GAZEBO_MODEL_DATABASE_URI: URI of the online model database where Gazebo will download models from. The default values of these environment variables are stored in the <install_path>/share/gazebo/setup.sh file. If you want to change the values of this variables for example, add or remove a path from GITHUB_MODEL_PATH you will have to source this file first using the command source <install_path>/share/gazebo/setup.sh Once this is done you can edit that value of the variable by editing the value by opening the setup.sh file or directly thorugh the terminal/command line using the command: GITHUB_MODEL_PATH=$GITHUB_MODEL_PATH:<path of the directory you want to add>","title":"Basics of Gazebo"},{"location":"simulation/gazebo/basics/#gazebo","text":"Gazebo is the most popular physics simulator for robotics development. It can simulate robots in a 3D environment and can be fully integrated into ROS integrated with Gazebo using the gazebo_ros ROS package. You can interface your robots in the simulation using ROS and control them using ROS messages and services.","title":"Gazebo"},{"location":"simulation/gazebo/basics/#21-installation","text":"Gazebo and gazebo_ros package are both automatically installed when you install ROS. To make sure you have all the ROS packages necessary for running Gazebo simulations are installed sudo apt-get install ros-melodic-gazebo-* Gazebo can also be installed independently of ROS by using the command curl -sSL http://get.gazebosim.org | sh in the terminal for Ubuntu. Alternative methods of installing gazebo and installation guides for installling gazebo on other operating systems can be found here .","title":"2.1 Installation"},{"location":"simulation/gazebo/basics/#22-getting-started","text":"You can launch the Gazebo GUI simulator window by just running the command gazebo in the terminal. To understand how to spawn robot models in gazebo it is recommended to first get familiar with .urdf , .sdf and .world files. You can refer to the Robot Description section to read about these. A file can be opened simply by running the follwing command in the command line: gazebo <path/to/file>","title":"2.2 Getting Started"},{"location":"simulation/gazebo/basics/#23-client-server-separation","text":"Running the gazebo command starts two programmes, namely the gzserver and the gzclient . The gzserver is responsible for doing most of the \u2018processing\u2019 part, i.e., doing all the calculations for the simulation, sensor data generation, basically all the backend processing. The gzclient is responsible for generating the user interface. It provides a nice visualization of simulation, and convenient controls over various simulation properties. gzserver is capable of running independently of gzclient and vice-versa. For eg; in many cases gzserver is run on a cloud computer in case enough processing power is not available locally. Try running the command gzserver in one terminal and the command gzclient in other terminal. You will notice that the gazebo window pops up only when you run the gzclient command. The term run headless is used to refer to cases when only the gzserver is being used.","title":"2.3 Client Server Separation"},{"location":"simulation/gazebo/basics/#24-environment-variables-in-gazebo","text":"Environment Variables are variables whose values are valid throughout the system and are used by different applications and the OS for several purposes. These environment variables can contain different types of things ranging from parameter values to paths to certain files depending on what they are used for. Gazebo uses various such environment variables too. These variables and their uses are described below: GAZEBO_MODEL_PATH : This environment variable contains colon-separated paths to different directories where gazebo will search for models. Models refers to the sdf file describing the robot. For more information on this refer to the Robot Description section of the handbook. GAZEBO_RESOURCE_PATH: This environment variable contains colon-separated set of directories where Gazebo will search for other resources such as world and media files. For eg. if you run the command gazebo worlds/pioneer2dx.world . You will see gazebo window pop up with an empty environment. In fact you can execute this command in any directory. You might ask how does gazebo know where the worlds directory is stored?. The answer is that the path to the world directory, that is /usr/share/gazebo-7/worlds is stored in the environment variable GAZEBO_RESOURCE_PATH . GAZEBO_MASTER__URI: URI of the Gazebo master . This specifies the IP and port where the server(gzserver) will be started and tells the clients(gzclients) where to connect to. GAZEBO_PLUGIN_PATH: colon-separated set of directories where Gazebo will search for the plugin shared libraries at runtime. Plugins are basically..... You can refer to this section to read more about gazebo plugins. GAZEBO_MODEL_DATABASE_URI: URI of the online model database where Gazebo will download models from. The default values of these environment variables are stored in the <install_path>/share/gazebo/setup.sh file. If you want to change the values of this variables for example, add or remove a path from GITHUB_MODEL_PATH you will have to source this file first using the command source <install_path>/share/gazebo/setup.sh Once this is done you can edit that value of the variable by editing the value by opening the setup.sh file or directly thorugh the terminal/command line using the command: GITHUB_MODEL_PATH=$GITHUB_MODEL_PATH:<path of the directory you want to add>","title":"2.4 Environment Variables in Gazebo"},{"location":"simulation/stdr/Basics/","text":"General Introduction STDR is a simple two dimensional robot simulator. It is very useful in cases where there is no need for computationally costly 3-D simulation of robots. It is computationally light and serves the purpose good. Hence it is very useful for learning based robotics or for multi robot simulation. Installation For ROS Kinetic, stdr can be installed using apt-get. For ROS Melodic, it is advisible to install stdr from source . Architecture Overview (Reference: ROS Wiki ) Basic Usage The stdr_launchers package contains launch files basic usage. However, custom launch files can be created to serve personal purposes easily. Some of the launch files are server_no_map.launch launches the stdr server without any map, robot or the gui. server_with_map_and_gui.launch launches the serve with preloaded map and gui. server_with_map_and_gui_plus_robot.launch launches the stdr_server, with preloaded map and robot along with the gui You can also launch Rviz with a preset config file using rviz.launch file in the stdr_launchers package. Robot Namespaces The topics corresponding to each robot have a unique namespace attached to it. For example the first robot launched has a namespace /robot0 . Published topics pertaining to that robot are published as /robot0/topic_name . Note that whenever a new robot is spawned the robot number is incremented by 1. This happens even though you delete a robot. such namespacing avoids conflicts of topic names when doing multi robot simulation. References For more information refer the stdr_simulator page in ROS Wiki . The github repository for stdr_simulator.","title":"Basics of STDR"},{"location":"simulation/stdr/Basics/#general-introduction","text":"STDR is a simple two dimensional robot simulator. It is very useful in cases where there is no need for computationally costly 3-D simulation of robots. It is computationally light and serves the purpose good. Hence it is very useful for learning based robotics or for multi robot simulation.","title":"General Introduction"},{"location":"simulation/stdr/Basics/#installation","text":"For ROS Kinetic, stdr can be installed using apt-get. For ROS Melodic, it is advisible to install stdr from source .","title":"Installation"},{"location":"simulation/stdr/Basics/#architecture-overview","text":"(Reference: ROS Wiki )","title":"Architecture Overview"},{"location":"simulation/stdr/Basics/#basic-usage","text":"The stdr_launchers package contains launch files basic usage. However, custom launch files can be created to serve personal purposes easily. Some of the launch files are server_no_map.launch launches the stdr server without any map, robot or the gui. server_with_map_and_gui.launch launches the serve with preloaded map and gui. server_with_map_and_gui_plus_robot.launch launches the stdr_server, with preloaded map and robot along with the gui You can also launch Rviz with a preset config file using rviz.launch file in the stdr_launchers package.","title":"Basic Usage"},{"location":"simulation/stdr/Basics/#robot-namespaces","text":"The topics corresponding to each robot have a unique namespace attached to it. For example the first robot launched has a namespace /robot0 . Published topics pertaining to that robot are published as /robot0/topic_name . Note that whenever a new robot is spawned the robot number is incremented by 1. This happens even though you delete a robot. such namespacing avoids conflicts of topic names when doing multi robot simulation.","title":"Robot Namespaces"},{"location":"simulation/stdr/Basics/#references","text":"For more information refer the stdr_simulator page in ROS Wiki . The github repository for stdr_simulator.","title":"References"}]}